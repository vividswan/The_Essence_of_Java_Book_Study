# Chapter 02 - 변수

## 변수(variable)

### 변수란?

`단 하나의 값을 저장할 수 있는 메모리 공간`  
새로운 값을 저장하면 기존의 값은 사라짐

### 변수의 선언과 초기화

> (변수 타입) (변수 이름);  

- 변수 타입은 저장될 타입
    - 자바는 정수형, 실수형, 문자형 ...
- 변수 이름은 메모리 공간에 붙은 이름
    - 저장된 값을 읽어올 때 사용
    - 서로 구별되어야 함
- 선언 시 변수 타입에 알맞은 크기의 저장 공간이 확보

변수의 초기화
- 초기화란 `변수를 사용하기 전에 처음으로 값을 저장`
- 메모리는 여러 프로그램이 공유하는 자원이므로 필수
    - 알 수 없는 쓰레기 값이 남아있을 수도 있기 때문
    - 클래스 변수와 인스턴스 변수는 초기화 생략 가능
    - 지역 변수는 반드시 초기화를 해야 함
- 대입 연산자 사용
    - 수학과는 다르게 오른쪽의 값을 왼쪽에 저장하라는 뜻
- 콤마로 여러 줄을 한 줄에 선언도 가능
```java
int a;
int b;
// int a, b;
int x = 0;
int y = 0;
int x = 0, y = 0;
```

두 변수의 값 교환하기

```java
int x = 10;
int y = 20;

x = y;
y = x;
```
위의 결과는 x의 값이 y의 값으로 바뀌었기 때문에 소용없다.  
tmp를 선언 후 변경 (물과 우유가 담긴 컵에 빈 컵을 추가하듯 ...)

```java
int x = 10;
int y = 20;
int tmp;
tmp = x;
x = y;
y = x;
```

덧셈 연산자는 두 값을 더하기도 하지만, 문자열과 숫자를 결합하기도 함
- 문자열 -> 큰따옴표("")로 묶은 연속된 문자
- ex) System.out.println("x:" + 10) -> System.out.println("x:10")

### 변수의 명명 규칙
변수의 이름처럼 프로그래밍에서 사용하는 모든 이름은 식별자  

식별자의 규칙
- 대소문자가 구분 & 길이 제한 x
- 예약어는 사용 X
    - true는 X, True는 O
    - 예약어는 매우 많으므로 차차 익혀가야 함
    - 예약어들은 클래스, 변수, 메서드의 이름으로 사용 X
- 숫자로 시작 X
- 특수문자는 '_'와 '&'만 허용

자바 프로그래머들에게 권장하는 규칙
- 클래스 이름의 첫 글자는 항상 대문자
    - 클래스 이름은 ASCII 코드로 (유니코드를 인식하지 못하는 OS를 위해)
- 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자
- 상수의 이름은 모두 대문자 & 여러 단어일 시 '_'
    - ex) PI, MAX_NUMBER
- 위 규칙들은 개발자들 사이의 암묵적 약속
- 특별한 방식으로 식별자를 작성해야 할 땐 미리 규칙을 세워서 일관되게 적용할 것
    - coding convention
- 변수의 이름은 짧으면 좋지만 길더라도 용도를 알기 쉽게 `의미 있는 이름`으로 할 것

## 변수의 타입

- 값?
    - 문자와 숫자(정수, 실수)

### 기본형과 참조형

기본형 : 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)

참조형 : 객체의 주소를 저장, 8개의 기본형을 제외한 나머지

참조 변수를 선언하는 방법

> 클래스이름 변수이름;


ex) Date today = new Date();

- new의 생성 결과는 객체의 주소
- 대입 연산자(=)에 의해 참조 변수 today에 객체의 주소가 저장

자료형 vs 타입
- 타입이 자료형을 포함하는 넓은 의미
- 참조형 변수는 타입을, 기본형은 자료형이란 용어를 사용

### 기본형

9개의 타입

- 논리형
    - boolean (true or false)
- 문자형
    - char (문자를 저장하는 데 사용)
- 정수형
    - byte, short, **int**, long (정수를 저장하는 데 사용, short는 C언어와의 호환을 위해 생성)
- 실수형
    - float, **double** (실수를 저장하는 데 사용)

정수에선 int를 CPU가 가장 효율적으로 처리
- 메모리를 아끼기 위해선 byte나 short 사용

float보단 double이 높은 정밀도 (float의 정밀도는 7자리)

기본 자료형의 종류와 크기
- boolean -> 1byte
- char -> 2byte (유니코드)
- byte -> 1byte
- short -> 2byte (int의 절반)
- int -> 4byte
- long -> 8byte (int의 2배)
- float -> 4byte
- double -> 8byte

### 상수와 리터럴

**상수**

- 변수와 마찬가지로 `값을 저장할 수 있는 공간 & 한번 값을 저장하면 변경 X`
- final 키워드를 앞에 붙여줘야 함
- JDK1.6부터 선언과 동시에 초기화하지 않아도 되지만 웬만하면 선언과 동시에 초기화할 것
- 상수의 이름은 모두 대문자 (여러 단어의 경우 '_' 사용)

> final int MAX_SPEEP = 100;

**리터럴**

- 12, 123, 3.14, 'A' 와 같은 값들이 리터럴
- 리터럴은 보통 알고 있는 상수

> 변수 : 하나의 값을 저장하기 위한 공간  
> 상수 : 값을 한 번만 저장할 수 있는 공간  
> 리터럴 : 그 자체로 값을 의미하는 것  

```java

    int year = 2014;
    final int MAX_VALUE = 100;

    // 2014, 100 -> 리터럴
    // year -> 변수
    // MAX_VALUE -> 상수
```

**상수가 필요한 이유**

- 리터럴에 `의미 있는 이름`을 붙여서 코드의 이해 및 수정을 쉽게 하기 위함
- ex) 삼각형의 폭, 높이를 상수로 선언 후 필요할 때 초기화 코드를 변경

리터럴의 타입과 접미사

- 정수형의 경우, long 타입의 리터럴에 접미사 'l' 또는 'L'을 붙임 (1과 안 헷갈리게 'L' 권유)
    - 접미사가 없을 시 int 타입의 리터럴
    - byte와 short는 별도로 존재 x (int 타입의 리터럴로 저장)
    - 8진수는 앞에 0, 16진수는 0x 또는 0X, 2진수는 0b 또는 0B의 접두사
- 실수형의 경우 float 타입은 'f', doubel 타입에는 'd'
    - 접미사가 없으면 double 타입 리터럴로 인식
- 10의 제곱은 e, E로 나타냄
- 잘 쓰이지는 않지만 2의 제곱의 의미로 p도 사용
    - ex) 0x1p1 = (1 x 16^0) x 2^1

**타입의 불일치**

타입이 달라도 저장 범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용
- 그 반대는 컴파일 에러

**문자 리터럴과 문자열 리터럴**

문자 리터럴 : 작은따옴표로 문자 하나를 감싼 것  
문자열 리터럴 : 큰 문자열로 감싼 것 (두 문자 이상은 문자열임)  

- 문자열 리터럴은 빈 문자열이 허용
    - 문자는 반드시 '' 안에 하나의 문자 필요
- String name = "test"는 String name = new String("test")와 같음
- 덧셈 연산자 사용 가능
    - 피연산자 모두 숫자일 땐 숫자를 더함
    - 어느 한쪽이라도 String 이면 나머지 한 쪽도 String으로 변환 후 String 결합
    - 왼쪽에서 오른쪽 방향으로 수행하기 때문에 결합 순서에 따라 결과가 달라짐
    
**형상화된 출력 - printf()**

println() 보다 값을 여러 형식으로 출력 가능

- 지시자가 필요
- 지시자와 출력될 값의 순서와 개수가 일치해야 되고 제한은 없다.
- println()과 달리 줄바꿈이 없으므로 `'%n'`을 넣어줘야 한다.
    - OS마다 줄바꿈 문자가 다를 수 있으므로 '\n'보다는 '%n'
- 자주 사용되는 지시자
    - %b : 불리언 형식으로 출력
    - %d : 10진 정수의 형식으로 출력
    - %o : 8진 정수의 형식으로 출력
    - %x, %X : 16진 정수의 형식으로 출력
    - %f : 부동 소수점 형식으로 출력
    - %e, %E : 지수 표현식의 형식으로 출력
    - %c : 문자로 출력
    - %s : 문자열로 출력
- 지시자 사이에 숫자를 추가하면 원하는 만큼의 출력 공간을 확보하거나 문자열의 일부만 출력
    - 실수형 일 땐 `%전체 자리.소수점 아래 자리f`
    - N : 최소 N글자 출력 공간 확보 (우측 정렬)
    - -N : 최소 N 글자 출력 공간 확보 (좌측 정렬)
    - . : 왼쪽에서 N 글자만 출력

**화면에서 입력받기 -Scanner**

Scanner에 대한 본격적인 학습 전 가져와서 사용하는 방법

- import java.util.*; 선언
- Scanner scanner = new Scanner(System.in); 으로 객체 생성
- scanner.nextLine(); 을 통해 입력받은 내용을 저장
- 파싱이 필요할 땐 nextInt나 nextFloat 사용
    - nextInt()와 같은 메서드는 값을 입력받아서 사용하기에 까다로움


## 진법

### 10진법과 2진법

- 일상에서 자주 사용하는 것은 10진법 (10개의 손가락)
- 컴퓨터는 1,0 (전기가 흐르거나, 흐르지 않거나) -> 2진법이 적합
- 2진법은 10진법에 비해 많은 자릿수가 필요
    - 자릿수만 주어지면 10진수 온전히 표현 가능

### 비트와 바이트

- 한 자릿수의 2진수가 `비트(bit)`
- 8비트를 `1바이트(byte)`
    - `niddle`은 4비트
- `워드(word)`는 CPU가 한 번에 처리할 수 있는 데이터의 크기
    - 성능에 따라 32비트 or 64비트
- n 비트로 표현할 수 있는 10진수
    - 값의 개수 : 2^n
    - 값의 범위 : 0 ~ 2^n-1

### 8진법과 16진법

- 8진수는 2진수 3자리
    - 2진수를 뒤에서부터 3자리씩 끊어서 교환
- 16진수는 2진수 4자리
    - 2진수를 뒤에서부터 4자리씩 끊어서 교환
    - A~F를 추가로 사용 (A부터 10)

### 정수의 진법 변환

- 10진수를 n 진수로 변환
    - 해당 진수로 나누고 나머지 값을 옆에 적는 것을 반복
    - 더 이상 나눌 수 없을 때까지 한 다음 몫과 나머지를 아래로부터 위로 순서대로 적기
- n 진수를 10진수로 변환
    - 각 자리의 수에 해당하는 단위의 값을 곱한 것의 합

### 실수의 진법변환

- 10진 소수점 수를 2진 소수점 수로 변환하는 방법
    - 10진 소수에 2를 곱하기
    - 그 결과에서 소수부만 가져다가 다시 2를 곱하기
    - 소수부가 0이 될 때까지 반복
    - 0과 . 뒤에 해당 결과를 순서대로 적기
- 2진 소수점 수를 10진 소수점 수로 변환하는 방법
    - 소수점 자릿수에 해당되는 진법의 마이너스 제곱 곱한 것의 합

### 음수의 2진 표현 - 2의 보수법

음수 표현 방법

- 왼쪽의 첫 번째 비트가 0이면 양수, 1이면 음수
    - 두 수를 더했을 때 2진수로 0이 되지 않는 단점
    - 0이 두 개(0, -0) 존재하는 단점
    - 2진수가 증가할 때 10진 음수는 감소

- 2의 보수법으로 표현
    - 절댓값이 같은 양수와 음수를 더하면 2진수로도 0을 얻음
    - 2진수가 증가할 때 10진 음수도 감소
    - 첫 번째 비트를 바꾸는 것만으로 값의 부호를 바꿀 순 없음


**2의 보수법**

- n의 보수 : 더했을 때 n이 되는 수
    - 2의 보수 : 더해서 2가 되는 두 수의 관계
    - 2는 2진수로 '10' -> '10'은 `자리 올림이 발생하고 0이 되는 수`
    - 그러므로 2의 진수는 더하면 자리 올림이 발생하고 0이 됨
- 음수를 2진수로 표현하기
    - 10진 음의 정수의 절댓값을 2진수로 변환
    - 1의 보수로 변환 후 더하기 1

## 기본형

### 논리형 - boolean

- true or false
- 대답, 스위치 등의 논리 구현에 사용
- 1byte (자바의 최소 단위는 1byte임으로)
- 대소문자 구별 주의

### 문자형 - char

- 단 하나의 문자만을 저장
- 문자의 유니코드인 정수가 저장되는 것
    - 리터럴 대신 문자의 유니코드를 저장 가능
- int형에 char형 변수를 대입 시 정수형으로 캐스팅할 것
    - 해당 변수에 들어있는 문자의 유니코드를 알 수 있음
- 특수문자
    - \t(tab)
    - \b(백스페이스)
    - \f(form feed)
    - \n(new line)
    - \r(캐리지 리턴)
    - \\(역슬래쉬)
    - \`(작은따옴표)
    - \"(큰따옴표)
    - \u유니코드(16진수인 유니코드 문자)
- 크기는 2byte
    - 2^16의 코드 사용 가능
    - 음수를 표현하지 않으므로 표현 가능한 정수의 개수는 0 ~ 2^16 - 1
- 인코딩은 문자를 유니코드로, 디코딩은 그 반대
- 아스키는 7bit 부호
    - 128개 문자의 집합 (기호, 숫자, 영어의 대소문자)
- 확장 아스키
    - 아스키의 남은 1bit를 활용
    - 국가나 기업에서 필요에 따라 다르게 정의
    - 한글은 조합형(초,중,종성을 조합), 완성형(아스키의 일부 영역의 두 문자 코드를 결합)
    - 현재 한글은 조합형 사용 x
- 코드 페이지
    - 확장 아스키의 256개 문자를 어떤 숫자로 변환할 것인지 적어놓은 문자 코드표
- 유니코드
    - 전 세계의 모든 문자를 하나의 통일된 문자 집합으로 표현
    - 2 byte + 21 bit(보충 문자)
    - 보충 문자는 char형이 아닌 int형으로 (거의 사용되지 않음)
    - 자바는 UTF - 16을 사용 (모든 문자를 2byte의 고정 크기로 표현 및 처음 128문자는 아스키와 동일)
    - UTF는 유니코드 문자 셋(포함시키고자 하는 문자들의 집합)
    - 16은 문자 셋의 번호
    - UTF - 8은 하나의 문자를 1~4 byte의 가변크기로 표현
    - UTF - 16은 문자를 다루기가 편리(크기가 고정)
    - UTF - 8은 숫자는 1 바이트, 한글은 3바이트로 표현 -> 가변적이므로 다루기 어렵지만 전송속도가 중요한 곳에서 사용이 늘고 있다.

### 정수형

byte(1byte) < short(2byte) < **int(4byte)** < long(8byte)

정수형의 표현 방식
- 왼쪽의 첫 번째 비트는 부호 비트
- 나머지는 값을 표현하는 데 사용
- n 비트로 표현할 수 있는 정수의 개수 -> 2^n 개
- 부호가 있는 정수의 범위는 -2^(n-1) ~ 2^(n-1) -1

정수의 선택 기준
- JVM의 피연산자 스택은 4byte 단위로 저장
    - byte, short는 변환하여 연산이 수행되어 오히려 느림
    - 그러므로 byte, short는 성능보다 저장 공간이 중요할 때 사용할 것
- 정수 선언 시 int 타입으로 선언 후 int의 범위`(대략 -20억~+20억)`를 넘어가면 long을 사용할 것

정수의 오버플로우
- 타입이 표현할 수 있는 값의 범위를 넘어서는 것
- 최댓값 + 1 -> 최솟값
- 최솟값 -1 -> 최댓값

부호 있는 정수의 오버플로우
- 부호 있는 정수는 부호 비트가 0에서 1이 될 때 오버플로우가 발생

### 실수형 - float, double

실수형의 범위와 정밀도
- float -> 정밀도 7자리, 크기는 4byte
- double -> 정밀도 15자리, 크기는 8byte
- 얼마나 큰 값을 표현할 수 있는가도 중요하지만 얼마나 0에 가까운 값을 표현할 수 있는지도 중요
- 실수형은 오버플로우가 발생하면 값이 무한대가 된다.
- 실수가 표현할 수 없는 아주 작은 값이 되는 경우는 언더플로우
- float 타입의 표현 방식
    - S(1)[부호] + E(8)[지수] + M(23)[가수]
    - 7자리 이상의 정밀도가 필요할 시 double형
- '%f'는 기본적으로 소수 7번째 자리에서 반올림

실수형의 저장 형식
- (부호[S])가수[M] * 2^지수[E]
- float : 1 + 8 + 23
- dobule : 1 + 11 + 52
- 부호는 0이면 양수, 1이면 음수
- 지수는 부호 있는 정수
    - -127, +128은 무한대를 위한 특별한 값의 표현 예약
- 가수는 실제 값을 저장하는 부분
    - **2^23이 대략 7자리의 10진수이므로 float의 정밀도가 7자리!**

부동소수점의 오차

- 2진수로는 10진수를 정확히 표현할 수 없기에 오차
- 지수는 기저 법으로 저장 (ex. 127을 더해줌)
    - 기저 법은 부호 있는 정수를 저장하는 방법을 뜻함
- 정규화 : 2진수로 변환된 실수를 1.xxx * 2^n의 형태로 변환하는 과정

## 형변환

변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능
- 기본형과 참조형끼리는 형변환 X

방법 => (타입)피연산자
- 괄호는 캐스트 연산자(형변환 연산자) -> 지정된 타입으로 형변환 뒤 반환

정수형간의 형변환
- 큰 타입에서 작은 타입으로의 변환은 값손실이 일어날 수 있음
- 작은 타입에서 큰 타입으로의 변환은 값 손실 X, 빈 공간이 1이나 0으로 채워짐
    - 음수인 경우 1로 채워짐

실수형 간의 형변환
- float -> double
    - 지수는 float의 기저인 127을 뺀 후 double의 기저인 1023을 더함
    - 가수는 float의 가수 23자리를 채우고 남은 자리를 0으로 채움
- double -> float
    - 지수는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더함
    - 가수는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려짐
    - 가수의 24번째 자리에서 반올림이 발생할 수도 있음
    - float 타입의 범위를 넘는 값을 float로 변환하는 경우 +- 무한대 or +-0이 결과

정수형과 실수형 간의 형변환
- 정수형 -> 실수형
    - 정수를 2진수로 변환 후 정규화
    - 실수형이 정수형보다 훨씬 큰 저장 범위
    - 실수형의 정밀도로 인한 오차 발생 가능(float는 7자리의 정밀도, double은 15자리)
- 실수형 -> 정수형
    - 실수형의 소수점 이하 값은 버려짐
    - 반올림은 발생 X
    - 소수점을 버리고 남은 정수가 정수형의 범위를 넘는 경우엔 오버플로우

자동 형변환
- 대입이나 연산 시 컴파일러가 생략된 형변환을 자동으로 추가(할당하는 타입이 클 경우)
- 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장할 땐 형변환 생략 시 에러
- 서로 다른 두 타입 간의 덧셈에선 표현 범위가 더 넓은 타입으로 형변환
    - 값 손실의 위험을 줄이기 위해
- `기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환이 규칙`
    - byte -> (short or char) -> int -> long -> float -> double
