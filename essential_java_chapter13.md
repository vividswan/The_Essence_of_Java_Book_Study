# Chapter 13 - 쓰레드(Thread)

## 1. 프로세스와 쓰레드

- process : 실행 중인 프로그램
  - OS로부터 실행에 필요한 자원(메모리)을 할당받은 후 프로세스가 됨
  - 데이터, 메모리 등의 자원, 쓰레드로 구성
  - 쓰레드가 프로세스의 자원을 이용해서 실제 작업 수행
  - 모든 프로세스에선 최소 하나의 쓰레드가 존재
  - 둘 이상의 쓰레드를 가지면 `멀티쓰레드 프로세스`
  - 메모리 한계에 따라 생성할 수 있는 쓰레드 수가 결정

멀티태스킹과 멀티쓰레딩

- 대부분의 OS는 멀티태스킹 지원
  - 여러 개의 프로세스가 동시에 실행 가능
- 멀티캐스팅처럼 멀티 쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행
  - 코어가 아주 짧은 시간 동안 여러 작업을 번갈아가며 수행함 -> 모두 동시에 수행되는 것처럼 느껴짐
  - 예) 파일 다운로드를 하면서 메신저를 하는 행동
- 많은 쓰레드를 가진다고 프로세스의 성능이 올라가는 것은 아님

멀티쓰레딩의 장단점

- 장점
  - CPU 사용률 향상
  - 자원을 더 효율적으로 사용
  - 사용자에 대한 응답성 향상
  - 작업이 분리되어 코드가 간결해짐
  - 프로세스를 생성하는 것에 비해 쓰레드를 생성하는 것이 더 적은 시간과 공간 필요
- 단점
  - 여러 쓰레드가 같은 프로세스의 자원을 공유하므로 동기화, 교착상태 문제들을 고려해야 함
  - 교착상태 : 두 쓰레드가 서로 필요한 자원을 점유한 상태에서 기다리느라 지원이 멈춰지는 상황

## 2. 쓰레드의 구현과 실행

- 구현 내용은 run() 메서드의 몸통에 구현
- Thread 클래스를 상속

```java
  class MyThread extends Thread{
    public void run(){
      // 구현 내용
    }
  }
```

- Ruunnable 인터페이스를 구현
  - 다른 클래스를 상속받을 수 있으므로 이 방법을 더 선호

```java
  class MyThread implements Runnable{
    public void run(){
      // 구현 내용
    }
  }
```

- 두 방식은 인스턴스 생성 방식이 다름
  - Thread 클래스를 상속받는 경우엔 new 연산자로 생성
  - Runnable 인터페이스를 구현한 경우 new Thread() 생성자의 매개변수로 제공해야 함
- 쓰레드 내부 코드에서 run 호출 시 Runnable의 run()을 호출하게 해놨으므로 run() 메소드를 오버라이딩 할 필요가 없음
- 단 Runnable 인터페이스를 구현한 경우엔 Thread 클래스의 메서드를 직접 호출할 순 없음
  - 제공된 static currentThread()를 호출하여 쓰레드에 대한 참조를 가져와야 함
  - ex) Thread의 이름을 알고 싶을 땐 `Thread.currentThread().getName()` 호출
- 쓰레드의 이름은 생성자 및 메서드로 변경 가능, 지정을 안 하면 `Thread-번호`

쓰레드의 실행 - start()

- run()을 구현했다고 쓰레드가 실행되는 것이 아님
- start()로 쓰레드를 호출해야만 실행
  - 실행되기보단 실행 대기로 바뀌고 자신의 차례가 되어야 실행
- 한 번 종료된 쓰레드는 다시 실행할 수 없음
  - 한 번 더 작업을 수행하기 위해선 new 생성자로 새로운 인스턴스를 생성 후 실행

## 3.start()와 run()

- start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성 후 run()을 호출
- 두 개 이상의 호출 스택이 존재할 땐 스케줄러가 정한 순서에 의해서 교대로 실행
  - 호출 스택의 가장 위에 있는 메서드가 실행 (나머지 메서드는 대기)
  - 주어진 시간 내로 작업을 마치지 못한다면 자신의 차례가 돌아올 때까지 대기

main 쓰레드

- main 메서드의 작업 또한 쓰레드가 실행 -> main 쓰레드라고 부름
  - 프로세스가 최소로 필요한 쓰레드
- main 쓰레드는 사용자 쓰레드이며 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료
- 한 쓰레드에서 예외 발생 종료 시 다른 쓰레드에는 영향을 미치지 않음
- start()가 아닌 run() 호출 시 쓰레드가 생성되지 않고 run() 호출 후 호출 스택에 쌓임

### 4. 싱글쓰레드와 멀티쓰레드

두 개의 작업을 하나의 쓰레드로 처리하는 경우와 두 개의 쓰레드로 처리하는 경우

- CPU만을 사용하는 싱글 코어에선 멀티쓰레드 보다 싱글 쓰레드로 프로그래밍 하는 것이 효율적
  - 처리 시간은 동일하게 걸리지만 멀티쓰레드는 컨텍스트 스위칭의 시간도 추가되고 한 쓰레드가 다른 쓰레드의 출력이 끝나기를 기다려야 하므로 더 오래 걸린다.
  - 컨텍스트 스위칭 시 다음에 실행해야 할 위치인 PC 등의 정보를 저장하고 읽어온다.
  - 프로세스 컨텍스트 스위칭보단 쓰레드 컨텍스트 스위칭이 더 적은 시간이 소요된다.
- 싱글 코어일 때와는 다르게 멀티 코어 일 때는 두 쓰레드가 수행될 수 있으므로 겹치는 부분이 발생
  - 화면 등의 자원을 놓고 쓰레드가 경쟁
- 실행 중인 프로세스는 이 OS 프로세스 스케줄러의 영향을 받음
  - JVM이 쓰레드 스케줄러로 쓰레드의 실행 순서 및 실행 시간이 결정되는 것처럼 프로세스도 OS의 프로세스 스케줄러로 결정
  - 자바는 OS 독립적이지만 실제로 쓰레드는 OS에 종속적
- 두 쓰레드가 서로 다른 자원을 사용하는 경우에는 멀티 쓰레드 프로세스가 더 효율적
  - 데이터를 입력받는 작업, 네트워크로 파일을 주고받는 작업 등등 외부기기와의 입출력이 필요할 때
  - 싱글 쓰레드에서는 외부의 입력을 기다리는 동안 아무런 작업도 할 수 없음
  - 두 개의 쓰레드에서는 사용자의 입력을 기다리는 동안 다른 쓰레드가 작업을 처리

### 5. 쓰레드의 우선순위

- 우선순위 값에 따라 쓰레드가 얻는 실행 시간이 달라짐

쓰레드의 우선순위 지정하기

- 우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높아짐
- 쓰레드를 생성한 쓰레드로부터 우선순위를 상속받음
  - main 메서드를 수행하는 쓰레드는 우선순위가 5
- void setPriority(int newPriority) : 쓰레드의 우선순위를 지정한 값으로 변경
- int getPriority() : 쓰레드의 우선순위를 반환
- 멀티 코어에서는 쓰레드의 우선순위에 따른 차이가 거의 없음
  - 그저 더 많은 실행 시간과 실행 기회를 갖게 될 것이라고 기대할 수밖에 없음
  - PriorityQueue를 사용하여 우선순위가 높은 작업을 먼저 처리하도록 구현하는 게 더 나을 수도 있음

### 6. 쓰레드 그룹(thread group)

- 쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것
  - 폴더를 생성해서 관련된 파일을 관리하는 것과 비슷함
- 쓰레드 그룹에 다른 쓰레드 그룹을 포함 시킬 수 있음
- 쓰레드 그룹은 보안상의 이유로 도입
  - 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹만 변경하도록 하기 위해
- ThreadGroup을 사용하여 생성
- 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어야 함
  - 쓰레드 그룹을 지정하는 생성자를 사용하지 않는 쓰레드는 자신을 생성한 쓰레드와 같은 그룹에 속하게 됨
  - 그러므로 우리가 만드는 모든 쓰레드는 main 쓰레드 그룹의 하위
- JVM은 어플리케이션 실행 시 main과 system이라는 쓰레드 그룹 생성
  - main 메서드를 수행하는 쓰레드는 main 그룹에 속함
  - 가비지 컬렉션을 수행하는 Finalizer 쓰레드는 system 그룹에 속함
- ThreadGroup getThreadGroup() : 쓰레드 자신이 속한 그룹 반환
- void uncaughtException(Tread t, Throwable e) : 쓰레드 그룹의 쓰레드가 처리되지 않는 예외에 의해 실행이 종료되었을 때, JVM에 의해 이 메서드가 자동으로 호출

### 7. 데몬 쓰레드(daemon thread)

- 일반 쓰레드의 작업을 돕는 보조적인 역할 수행
  - 일반 쓰레드가 모두 종료될 시 데몬 쓰레드도 자동 종료
  - 예로는 가비지 컬렉터, 자동 저장, 화면 자동갱신 등등
- 특정 조건이 만족되면 수행 후 다시 대기
- 실행하기 전 setDaemon(true)를 호출
  - 쓰레드를 데몬 쓰레드나 사용자 쓰레드로 변경하는 메서드
  - 반드시 start()를 호출하기 전에 실행시킬 것
- 데몬 쓰레드가 생상한 쓰레드는 자동으로 데몬 쓰레드가 됨
- boolean isDaemon() 메서드로 쓰레드가 데몬 쓰레드인지 확인
- 프로그램을 시작 시 보조 작업을 하는 많은 데몬 쓰레드들이 실행됨
  - 각자 system 쓰레드 그룹, main 쓰레드 그룹에 속해있음

### 8. 쓰레드의 실행 제어

- 쓰레드의 상태

  - NEW : 쓰레드가 생성되고 start() 호출되기 전
  - RUNNALBE : 실행 중 or 실행 가능 상태
  - BLOCKED : 동기화 블럭에 의해 일시정지된 상태
  - WAITING, TIMED_WAITING : 쓰레드의 작업이 종료되지는 않았지만 실행 가능하지 않은 일시정지 상태 (TIME_WATING은 일시정지시간이 지정)
  - TERMINATED : 쓰레드의 작업이 종료된 상태

- 쓰레드의 생성부터 소멸 과정
  - start()를 호출하면 실행 대기열에 저장 후 자기 차례 기다림 (실행 대기열은 큐와 같은 구조)
  - 자신의 차례가 되면 실행상태
  - 주어진 실행 기간이 다되는 경우나 yield()를 만나면 실행 대기 상태로 다시 실행 대기열로 들어감
  - 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지가 될 수 있음
  - 지정된 일시정지 시간이 다 되는 경우, notify(), resume(), interrupt()가 호출되면 일시정지를 벗어나서 다시 실행 대기열로 들어감
  - 실행을 모두 마치는 경우, stop()을 호출하는 경우 쓰레드 소멸

sleep(long millis) - 일정 기간 동안 쓰레드를 멈추게 함

- 두 번째 파라미터를 넣을 시 나노세컨드까지 지정 가능
- static 메서드
  - **참조변수와 상관 없이 현재 실행 중인 쓰레드에 대해 작동**
  - 참조변수를 이용하기보단 `Thread.sleep()`으로 사용할 것
- 시간이 다 되거나 interrupt()를 호출해야 잠에서 깨어나 실행 대기 상태로 바뀜
- 항상 try-catch 문으로 예외 처리 필요
  - InterruptedException은 런타임 예외가 아니므로
  - try-catch 문을 다루는 메서드를 만들어서 사용하기도 함

interrupt()와 interrupted() - 쓰레드의 작업을 취소한다.

- interrupt()는 쓰레드에게 작업을 멈추라고 요청
  - 쓰레드를 강제로 종료시키지는 못함
  - 인스턴스 변수인 interrupted의 상태를 변경하는 것뿐 (true로)
- interrupted() 메서드로 쓰레드에 대해 interrupt가 호출되었는지 확인 가능 (interrupted의 상태를 호출해서)
  - 그 후 interrupted의 상태를 false로 변경
  - isInterrupted()는 쓰레드의 interrupted를 확인하는 것인 동일하지만 상태 변경 X
- sleep(), wait(), join()에서 interrupt() 호출 시 실행 대기 상태로 바뀜
  - 멈춰있을 때 interrupt()를 호출하면 InterruptedException이 발생되고 쓰레드의 interrupted의 상태는 false로 자동 초기화

suspend(), resume(), stop()

- suspend()는 sleep()처럼 쓰레드를 멈추게 함
  - resume()을 호출하면 다시 실행 대기 상태
  - stop()은 호출되는 즉시 쓰레드가 종료
- suspend()와 stop()이 교착상태를 일으키기 쉽게 작성되었으므로 사용 권장 X
  - deprecated 되어 있음
- suspend와 stop이 동작하지 않을 시 변수 앞에 volatile 선언

yield() - 다른 쓰레드에게 양보한다.

- yield()는 쓰레드 자신에게 주어진 실행 시간을 다음 차례의 쓰레드에게 양보
  - 할당받은 실행 시간을 사용하던 중 yield()를 만나면 나머지 실행 시간은 포기하고 다시 실행 대기 상태
- 프로그램의 응답성을 높이고 효율적인 실행을 위해 사용
  - 쓰레드가 실행을 멈추게 한 상태에서 while이 반복된다면 `바쁜 대기 상태`로 실행 시간을 의미 없이 낭비
  - 이때 yield()를 호출해서 남은 시간을 while
