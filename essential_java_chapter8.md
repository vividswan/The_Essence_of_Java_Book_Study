# Chapter 08 - 예외처리

## 예외처리

### 프로그램 오류

- 종류

  - 컴파일 에러 : 컴파일 시에 발생
  - 런타임 에러 : 실행 시에 발생
  - 논리적 에러 : 실행은 되지만, 의도한 대로 작동하지 않는 것

- 런타임에서 에러와 예외
  - 에러는 프로그램 코드에 의해서 수습될 수 없는 심각한 오류 (메모리 부족, 스택오버플로우)
  - 예외는 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

### 예외 클래스의 계층구조

- 모든 예외의 최고 조상은 Exception 클래스
  - Exception 클래스와 그 자손들 (사용자의 실수와 같은 외적인 요인으로 발생)
  - RuntimeException 클래스와 그 자손들 (주로 프로그래머의 실수로 발생)
  - Exception 클래스의 자손들을 이렇게 두 그룹으로 나눌 수 있음

### 예외처리하기 - try-catch문

- 정의 : 프로그램 실행 시 발생할 수 있는 예외에 대한 코드를 작성
- 목적 : 프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하기 위해
- 발생한 예외를 처리하지 못하면 프로그램이 비정상적으로 종료되며 JVM의 예외 처리기가 받아서 예외의 원인을 출력해 줌
- 구조
  - 하나의 try 블럭 다음에는 하나 이상의 catch 블럭
  - catch 블럭과 일치하는 예외의 종류가 아닐 시 예외 처리 X
  - catch 블럭 내에 또 try-catch를 만들 경우 같은 이름의 참조 변수를 사용하면 안 됨

### try-catch문에서의 흐름

- try 블럭 내에서 예외가 발생한 경우
  - 일치하는 catch 블럭을 찾음
  - 일치하는 catch 블럭을 찾으면 catch 블럭 내의 문장 수행 후 전체 try-catch 빠져나간 뒤 그다음 문장 수행
  - 일치하는 catch 블럭을 못 찾으면 예외는 처리되지 못함
- try 블럭 내에서 예외가 발생하지 않는 경우
  - catch 블럭을 거치지 않고 전체 try-catch 빠져나간 뒤 그다음 문장 수행

### 예외의 발생과 catch 블럭

- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 생성됨
- 첫 번째 catch부터 내려가면서 괄호 내에 선언된 참조 변수의 종류와 예외 클래스 인스턴스 확인
- 검사는 instanceof 연산자를 이용
- Exception 클래스를 catch에 선언하면 모든 예외를 처리 가능
- 예외가 발생했을 때 예외 클래스의 인스턴스에서 `getMessage()` 메소드는 발생한 예외 클래스의 인스턴스에 저장된 메세지를 얻을 수 있음
- 예외가 발생했을 때 예외 클래스의 인스턴스에서 `printStackTrace()` 메서드는 예외 발생 당시의 호출 스택에 있었던 메서드의 정보와 예외 메세지를 화면에 출력
- JDK 1.7부터 '|' 기호를 사용해 여러 catch 블럭을 하나로 합칠 수 있는 멀티 catch 블럭을 지원
  - 예외 클래스의 개수에는 제한 X
  - 두 예외 클래스가 조상과 자손의 관계일 시 불필요한 코드를 제거하라는 의미의 에러 발생
  - 멀티 catch 블럭에서 예외가 처리되면 실제로 어떤 예외가 발생했는지 알 수 없음 (참조 변수 e는 연결된 예외 클래스들의 공통분모인 조상 예외 클래스에 선언된 멤버만 사용 가능)
  - 참조 변수 e는 상수이므로 값을 변경 불가능

### 예외 발생시키기

- 키워드 `throw`를 사용해서 프로그래머가 고의적으로 예외 발생 가능
- 연산자 new를 이용해서 예외 클래스의 객체를 만든 뒤 throw
- Exception 클래스들은 발생할 가능성이 있는 모든 문장들에 대해 예외처리를 해줘야 함 (컴파일 되지 않음)
  - RuntimeException의 자손 클래스들은 컴파일 가능, 예외처리를 강제하지 않는다. (unchecked 예외)

### 메서드에 예외 선언하기

- 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 선언 가능
- 메서드에 발생 가능한 예외를 명시하여 견고한 프로그램 코드를 작성할 수 있도록 도와줌
- 메서드에 예외를 선언할 때 일반적으로 RuntimeException 클래스를 적지 않음
  - 보통 반드시 처리해 주어야 하는 예외들만 선언
- 메서드의 throws에 예외를 명시하는 것은 호출한 메서드에게 예외를 전달하여 떠맡기는 것을 의미
  - 반드시 어디선가는 처리를 해주어야 함

### finally 블럭

- 예외의 발생 여부에 상관없이 실행되어야 할 코드를 포함시킴
- try-catch 문의 끝에 선택적으로 덧붙여 사용
- try와 catch에 중복되는 내용이 있다면 finally 블럭에 포함시킬 것
- **try 블럭에서 return 문이 실행되는 경우에도 finally 블럭의 문장들이 먼저 실행된 후에 현재 실행 중인 메서드를 종료**
  - catch 블럭에서 return 문을 만났을 때도 마찬가지

### 자동 자원 반환 - try-with-resources 문

- JDK1.7부터 추가된 try-catch 문의 변형
- 주로 입출력에 관련된 구문에서 유용
  - 사용한 후에 자원을 반환해야 하기 때문에 반드시 종료해 줘야 하는 클래스들
- try 괄호 안에 객체를 생성하는 문장을 넣는 방식
  - 두 문장 이상 넣을 시 ';'로 구분
- 따로 close()를 호출하지 않아도 try 블럭을 벗어나는 순간 자동적으로 close() 호출
- close() 호출 후 catch 또는 finally 블럭이 수행
- 자동으로 close()가 호출될 수 있으려면 AutoCloseable이라는 인터페이스를 구현한 것이어야만 함
- 만약 close()에서 예외가 발생했을 시 `억제된(suppressed)`라는 의미의 머리말과 함께 출력
  - Throwable의 `void addSuppressed(Throwable exception)` 메소드로 억제된 예외를 추가 가능
  - Throwable의 `Throwable[] getSuppressed()`로 억제된 예외를 반환

### 사용자 정의 예외 만들기

- 보통 Exception 클래스 또는 RuntimeException 클래스로부터 상속받아 클래스를 만듦
  - 필요에 따라 알맞은 예외 클래스를 선택 가능
- 필요하다면 멤버 변수나 메서드를 추가 가능
  - 메시지, 에러코드 값 등등을 추가하여 getMessage()로 조회할 수 있도록 구현 가능
- `super(msg)`로 String을 매개변수로 받는 생성자를 추가 가능
- 기존에는 주로 Exception을 상속받아서 checked 예외로 작성하는 경우가 많았지만 요즘은 예외 처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아서 작성하는 쪽으로 바뀌고 있음
  - checked 예외는 불필요한 경우에도 try-catch문을 넣어줘야 하기 때문

### 예외 내던지기(exception re-throwing)

- 한 메서드에서 발생할 수 있는 예외가 여럿일 때 몇 개는 선언부에 지정(throw문), 몇 개는 try-catch 문으로 직접 처리하는 방법도 가능
- 단 하나의 예외에 대해서도 양쪽에서 처리하도록 나눌 수 있음
- 예외 내던지기란 `예외를 처리한 후에 인위적으로 다시 발생시키는 것`
- 예외 던지기를 위해 throw로 예외를 호출한 메서드 쪽에 전달하면 catch 블럭에서 return 문이 필요하지 않음

### 연결된 예외(chained exception)

- 예외 A가 예외 B를 발생시켰다면, `A를 B의 원인 예외`라고 부름
- 예외를 생성한 후에 `initCause()`로 원인 예외를 등록하고 throw로 예외를 던짐
- `initCause()`는 Exception 클래스의 조상인 Throwable 클래스에 정의된 것으로 모든 예외에서 사용 가능
  - Throwable initCause(Throwable cause) : 지정된 예외를 원인 예외로 등록 (Throwable 구현에선 객체 자신을 원인 예외로 등록)
  - Throwable getCause() : 원인 예외를 반환
- 여러 가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해 연결된 예외를 사용
  - 발생시킨 예외의 조상 클래스로 지정 후 구현 시 실제로 발생한 예외를 알 수 없는 문제를 해결하고 상속관계를 변경하는 부담을 줄임
  - 서로 상속관계가 아니어도 상관없음
- checked 예외를 unchecked 예외로 감싸는 방법 `(생성자의 매개변수로 예외 인스턴스를 넣으면 원인 예외로 등록됨)`으로도 많이 사용됨
