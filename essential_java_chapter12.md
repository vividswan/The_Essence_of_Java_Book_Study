# Chapter 12 - 제네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

- JDK 1.5에서 처음 도입

### 1.1 지네릭스란?

- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능
  - 타입 안정성을 높이고 형변환의 번거로움 감소

### 1.2 지네릭 클래스의 선언

- 클래스 옆에 `<T>`를 붙이고 Object 클래스를 모두 T로 변경
  - T는 `타입 변수`라고 부름 (T가 아닌 다른 것 사용해도 무관)
- 지네릭 클래스로 객체를 선언 시 참조변수와 생성자에 타입 T 대신 실제 타입을 지정
- 하위 호환을 위해 예전의 방식으로 객체를 생성하는 것도 허용하지만 안전하지 않다는 경고 발생
  - Object를 지정하면 경고 발생 X

지네릭스의 용어

- Example<T> : 지네릭 클래스
- T : 타입 변수 또는 타입 매개변수
- Example : 원시타입
- 지정된 타입을 `매개변수화된 타입`이라고 부름
- 컴파일 후에는 원시타입으로 바뀜 (지네릭 타입이 제거됨)

지네릭스의 제한

- 객체 생성 시 객체별로 다른 타입을 지정하는 것을 허용
- **모든 객체에 동일하게 동작해야 하는 static 멤버에 타입 변수 T를 사용할 수 없음**
- `new T[10]`과 같이 new 연산자와 함께 사용할 수 없음
  - 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 하므로
  - 지네릭 배열을 꼭 생성해야 하면 new 연산자 대신 newInstance()와 같은 동적으로 객체를 생성하는 메서드 or Object 배열을 생성해서 복사한 후 형변환

### 1.3 지네릭 클래스의 객체 생성과 사용

- 참조변수와 생성자에 대입된 타입이 일치해야 됨
  - 일치하지 않으면 에러 발생
  - 두 타입이 상속관계여도 에러 발생
  - **두 지네릭 클래스의 타입이 상속관계이며 대입된 타입이 같은 것은 허용**
  - JDK 1.7부터는 추정이 가능한 경우 타입 생략 가능
- 생성된 객체의 메소드가 매개변수로 타입 변수 객체를 받을 때 타입 변수의 자손들도 매서드의 매개변수가 될 수 있음

### 1.4 제한된 지네릭 클래스

- T만 선언하면 모든 종류의 타입을 지정할 수 있음
- 제네릭 타입에 `extends`를 사용하면 특정 타입의 자손들만 대입할 수 있게 제한 가능
- 인터페이스를 구현해야 하는 제약 역시 `extends`로 표현
  - implements를 사용하지 않음에 주의
  - 자손 제약과 구현 인터페이스가 존재한다면 `&` 기호로 연결 (\<T extends ExampleClass & ExampleInterface>)

### 1.5 와일드 카드

- 하나의 참조변수로 서로 다른 타입에 대입된 여러 지네릭 객체를 다루기 위해 사용
  - 메서드를 호출할 때마다 다른 타입을 대입해야 할 때 사용
- \<T extends Example> vs <? extends Example>
  - **\<T extends Example>는 메서드를 호출할 때마다 다른 지네릭 타입을 대입할 수 있게 한 것**
  - **\<? extends Example>는 하나의 참조변수로 서로 다른 타입에 대입된 여러 지네릭 객체를 다루기 위한 것**
- \<? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
- \<? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
- \<?> : 제한 없음. 모든 타입이 가능. (\<? extends Object>와 동일)

```java
  TestList<Parent> testList = new TestList<Parent>(); // 허용
  TestList<Parent> childTestList = new TestList<Child1>(); // 에러

  TestList<? extends Parent> wildCardChildTestList = new TestList<Child1>(); // 허용
  wildCardChildTestList = new TestList<Child2>(); // 허용
  wildCardChildTestList = new TestList<Child3>(); // 허용
```

### 1.6 지네릭 메서드

- 메서드의 선언부에 지네릭 타입이 선언된 메서드 **(클래스의 타입 변수가 선언되는 것이 아님!)**
- 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것
  - 같은 문자 T 일지라도
- 메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같음
  - 메서드 내에서만 사용될 것
- 메서드 호출 시 타입 변수에 타입을 대입해야 하지만 대부분의 경우 컴파일러가 추정 가능하므로 생략
  - 메서드를 호출할 때 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름 생략 불가
- public static \<T extends Comparable<? super T>> void sort(List\<T> list)
  - 타입 T를 요소로 하는 List를 매개변수로 허용
  - `T`는 Comparable을 구현한 클래스이어야 함
  - Comparable<? super T>이므로 Comparable의 매개변수는 T와 T의 조상 타입이 모두 가능

### 1.7 지네릭 타입의 형변환

- 지네릭 타입과 원시 타입 간의 형변환은 가능
  - 경고가 발생할 뿐
- 대입된 타입과 다른 지네릭 타입 간에는 형변환 불가능
  - Object여도 불가능
- 특정 타입을 `? extends Object`으로의 형변환도 가능
  - 반대로도 가능하지만 확인되지 않은 형변환이라는 경고 발생
- Optional\<Object>를 Optional\<String>으로 직접 형변환 하는 것은 불가능하지만 와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능
  - Optional\<Object> -> Optional<?> -> Optional\<T>

### 1.8 지네릭 타입의 제거

- 컴파일러는 지네릭 타입을 이용해서 소스파일을 체크 후 필요한 곳에 형변환을 넣어준 뒤 지네릭 타입 제거
  - \*.class 파일에는 지네릭 타입에 대한 정보가 없음
- 하휘 호환성을 유지하기 위함
  - 원시 타입으로 작성할 수 있도록 한 것도 마찬가지
- 기본적인 제거 과정
  1. 지네릭 타입의 경계를 제거 (~ extends XXX는 XXX로 변경, T만 있을 시 Object로 변경)
  2. 지네릭 타입을 제거한 후 타입이 일치하지 않으면 형변환 추가

## 2. 열거형(enums)

### 2.1 열거형이란?

- 서로 관련된 상수를 편리하게 선언하기 위한 것
- JDK 1.5부터 새로 추가
- 값뿐만 아니라 타입도 관리함 (C언어의 열거형보다 향상된 것)
  - 타입에 안전한 열거형(실제 값뿐만 아니라 타입도 체크)
- 상수와 다르게 열거형 상수는 기존의 소스를 다시 컴파일하지 않아도 됨

### 2.2 열거형의 정의와 사용

- enum 열거형이름 {상수명1, 상수명2, ...}
- statoc 변수를 참조하듯 `열거형이름.상수명`으로 참조
- `==`로 비교가 가능하나 <,> 같은 비교연산자는 사용 불가능
  - compareTo()는 사용 가능
- switch 문의 case 문에도 사용가 능한데 열거형의 이름은 적지 말고 상수만 적어야 함

모든 열거형의 조상 - java.lang.Enum

- getDeclaringClass(), name(), ordinal(), valueOf()를 Enum에서 갖고 있음
  - ordinal()은 0부터 시작하는 열거형의 순서 반환
  - name()은 열거형의 이름을 문자열로 반환
- values(), valueOf(String name)은 컴파일러가 자동적으로 추가해 주는 메서드
  - values()는 열거형의 모든 상수를 배열에 담아 반환
  - valueof()는 상수에 대한 참조를 얻게 해줌

### 2.3 열거형에 멤버 추가하기

- 열거형의 이름 옆에 원하는 값을 괄호와 함께 적어주면 가능
  - 그 후 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가 해야함
    - 열거형 상수를 모두 정의한 다음 다른 멤버들을 추가 해야함
    - 열거형 상수의 마지막에 ';'도 잊지 말 것
- 열거형 생성자는 제어자가 묵시적으로 private
- 여러 값에 맞는 인스턴스 변수와 생성자를 새로 추가한다면 열거형 상수에 여러 값을 저장할 수 있음

열거형에 추상 메서드 추가하기

- 열거형에 추상메서드를 선언하면 각 열거형 상수가 추상 메서드를 반드시 구현해야 함

### 2.4 열거형의 이해

- 열거형 상수 하나하나가 객체
- Enum 클래스의 static 상수인 열거형 상수들의 값은 객체의 주소이며 바뀌지 않으므로 `==`로 비교가 가능한 것
  - 서로의 ordinal을 빼주는 방식으로 구현

## 3. 애너테이션(annotation)

### 3.1 애너테이션이란?

- javadoc을 만들어내는 주석의 `@`이 붙은 태그 기능을 응용하여 만든 기능
- 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것
- 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공
  - 관련 있는 프로그램에만 영향
- JDK에서 제공하는 표준 에너테이션은 주로 컴파일러에게 유용한 정보 제공
  - 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션도 제공

### 3.2 표준 애너테이션

- 표준 애너테이션
  - @Override, @Deprecated, @SuppressWarnings, @SafeVarags, @FunctionalInterface, @Native
- 표준 애너테이션 중 메타 애너테이션
  - @Target, @Documented, @Inherited, @Retention, @Repeatable

@Override

- 메서드 앞에만 붙일 수 있음
- 조상의 메서드를 오버라이딩 하는 것이라는 걸 컴파일러에게 알려줌
- 메서드 이름을 잘 못 쓰면 컴파일러가 에러 출력
- 필수는 아니지만 실수를 방지 해주는 애너테이션

@Deprecated

- 더 이상 사용되지 않는 필드나 메서드에 붙이는 애너테이션
- 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권하는 의미

@FunctionalInterface

- 함수형 인터페이스를 선언할 때 이 애너테이션을 붙이면 컴파일러가 올바른 함수형 인터페이스인지 확인
- 잘못된 경우 컴파일러가 에러 출력
- 필수는 아니지만 실수를 방지해 주는 애너테이션

@SuppressWarnings

- 묵인해야 하는 경고가 발생하는 대상에 붙여서 컴파일 후에 어떤 경고 메시지도 나타나지 않게 함
- -Xlint 옵션으로 나오는 경고의 종류 중 대괄호[]안에 있는 경고를 억제할 수 있음
- 억제하는 경고로 주로 사용되는 것은 "deprecation", "uncheked", "rawtypes", "varargs"
- 배열처럼 괄호{}를 사용해 둘 이상의 경고를 동시에 억제할 수도 있음
- main() 메소드에 붙여서 해당 경고와 관련된 모든 메세지를 억제할 수 있지만 억제 범위를 최소화하는 것이 좋다.

@SafeVarargs

- 컴파일 후에도 제거되지 않는 타입은 reifiable, 제거되는 타입은 non-reifiable 타입
  - 지네릭 타입들은 대부분 컴파일 시에 제거되므로 non-reifiable 타입
- 메서드에 선언된 가변인자의 타입이 non-reifiable 타입일 경우 해당 메서드를 선언하눈 부분과 호출하는 부분의 "uncheked" 경고를 억제하기 위해선 @SafeVarargs 사용
  - 매개변수가 가변인자이면서 제네릭 타입인 경우 (ex- Arrays.asList(T... a))
  - 메서드에 선언된 타입 T는 컴파일 과정에서 Object로 바뀜
  - 컴파일러가 모든 객체가 들어올 수 있음을 경고
  - 하지만 지네릭스를 사용했기 때문에 컴파일러가 호출 부분을 체크해서 T 외에 다른 타입이 들어갈 수 없게 할 것이므로 위 코드는 안정
  - 이때 @SafeVarargs를 붙임
- @SuppressWarnings("unchecked")는 메서드 선언 부분과 호출되는 곳에서 애너테이션을 붙여야 하지만 @SafeVarargs는 메서드를 호출하는 곳에서 발생하는 경고도 억제
- 'varargs' 경고는 억제할 수 없으므로 @SuppressWarnings("varargs")와 함께 어노테이션을 붙임

### 3.3 메타 애너테이션

- 메타 애너테이션은 애너테이션을 정의할 때 사용

@Target

- 애너테이션이 적용 가능한 대상을 지정하는 데 사용
- 여러 개의 값은 괄호{}를 사용해야 함

@Retention

- 애너테이션이 유지(retention)되는 기간을 지정하는 데 사용
- 컴파일러가 사용하는 애너테이션의 유지 정책은 'SOURCE'
- 유지 정책이 'RUNTIME'일 시 실행 시에 리플렉션을 통해 클래스 파일에 저장된 애너테이션을 정보를 읽은 뒤 처리
- 유지 정책 'CLASS'는 컴파일러가 애너테이션의 정보를 클래스 파일에 저장할 수 있게 해줌
  - 클래스 파일이 JVM에 로딩될 시 애너테이션의 정보가 무시되므로 실행 시에는 정보를 얻을 수 없으므로 잘 사용 X

@Documented

- 애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 함

@Inherited

- 애너테이션이 자손 클래스에 상속되도록 함
  - 조상 클래스에 붙이면 자손 클래스도 이 애너테이션이 붙은 것과 같이 인식

@Repeatable

- @Repeatable이 붙은 애너테이션은 여러 번 붙일 수 있음
- 이 애너테이션들을 하나로 묶어서 다룰 수 있는 애너테이션도 추가로 정의해야 함

@Native

- 네이티브 메서드에 의해 참조되는 상수 필드에 붙이는 애너테이션
  - 네이티브 메서드는 JVM이 설치된 OS의 메서드를 의미
  - 보통 C언어로 작성
  - 자바에서는 메서드의 선언부만 정의하고 구현은 X
  - 추상메서드 처럼 선언부만 있고 몸통이 없음

### 3.4 애너테이션 타입 정의하기

- @ 기호를 붙이고 인터페이스를 정의하는 것과 동일

애너테이션의 요소

- 애너테이션 내에 선언된 메서드를 애너테이션 요소라고 부름
  - 반환값이 있고 매개변수는 없는 추상 메서드의 형태
  - 상속을 통해 구현하지 않아도 됨
  - 애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해 줘야 함
  - 지정할 때 순서는 상관 X
  - 각 요소는 기본값을 가질 수 있고 값을 지정하지 않을 시 사용됨
  - 에너테이션의 요소가 하나뿐이고 이름이 value 일 땐 요소의 이름을 생략 후 값만 적어도 적용 가능
  - 요소의 타입이 배열인 경우 괄호{}를 사용해서 여러 개의 값을 지정
  - 기본값 또한 괄호{}로 지정 가능

java.lang.annotation.Annotation

- 모든 애너테이션의 조상
- 애너테이션은 상속이 허용되지 않으므로 명시적으로 extends 지정 불가능
- Annotaion은 일반적인 인터페이스로 정의되어 있음
  - equals(), hashCode(), toString()과 같은 메서드들이 정의되어 있으므로 애너테이션 객체에서 호출 가능
- TestClass.class.getAnnotations()로 TestClass에 적용된 모든 애너테이션 호출 가능 및 인터페이스에 정의된 메서드 호출 가능

마커 애너테이션 Marker Annotation

- 요소가 하나도 정의되지 않은 애너테이션을 마커 애너테이션이라고 부름
  - 값을 지정할 필요가 없는 애너테이션들

애너테이션 요소의 규칙

- 반드시 지켜야 하는 규칙들
  - 요소의 타입은 기본형, String, enum, 애너테이션, class만 허용
  - () 안에 매개변수를 선언할 수 없다.
  - 예외를 선언할 수 없다.
  - 요소를 타입 매개변수로 정의할 수 없다.
- 클래스 객체에는 해당 클래스에 대한 모든 정보를 갖고 있고 애너테이션의 정보도 포함되어 있음
