# Chapter 12 - 제네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

- JDK 1.5에서 처음 도입

### 1.1 지네릭스란?

- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능
  - 타입 안정성을 높이고 형변환의 번거로움 감소

### 1.2 지네릭 클래스의 선언

- 클래스 옆에 `<T>`를 붙이고 Object 클래스를 모두 T로 변경
  - T는 `타입 변수`라고 부름 (T가 아닌 다른 것 사용해도 무관)
- 지네릭 클래스로 객체를 선언 시 참조변수와 생성자에 타입 T 대신 실제 타입을 지정
- 하위 호환을 위해 예전의 방식으로 객체를 생성하는 것도 허용하지만 안전하지 않다는 경고 발생
  - Object를 지정하면 경고 발생 X

지네릭스의 용어

- Example<T> : 지네릭 클래스
- T : 타입 변수 또는 타입 매개변수
- Example : 원시타입
- 지정된 타입을 `매개변수화된 타입`이라고 부름
- 컴파일 후에는 원시타입으로 바뀜 (지네릭 타입이 제거됨)

지네릭스의 제한

- 객체 생성 시 객체별로 다른 타입을 지정하는 것을 허용
- **모든 객체에 동일하게 동작해야 하는 static 멤버에 타입 변수 T를 사용할 수 없음**
- `new T[10]`과 같이 new 연산자와 함께 사용할 수 없음
  - 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 하므로
  - 지네릭 배열을 꼭 생성해야 하면 new 연산자 대신 newInstance()와 같은 동적으로 객체를 생성하는 메서드 or Object 배열을 생성해서 복사한 후 형변환

### 1.3 지네릭 클래스의 객체 생성과 사용

- 참조변수와 생성자에 대입된 타입이 일치해야 됨
  - 일치하지 않으면 에러 발생
  - 두 타입이 상속관계여도 에러 발생
  - **두 지네릭 클래스의 타입이 상속관계이며 대입된 타입이 같은 것은 허용**
  - JDK 1.7부터는 추정이 가능한 경우 타입 생략 가능
- 생성된 객체의 메소드가 매개변수로 타입 변수 객체를 받을 때 타입 변수의 자손들도 매서드의 매개변수가 될 수 있음

### 1.4 제한된 지네릭 클래스

- T만 선언하면 모든 종류의 타입을 지정할 수 있음
- 제네릭 타입에 `extends`를 사용하면 특정 타입의 자손들만 대입할 수 있게 제한 가능
- 인터페이스를 구현해야 하는 제약 역시 `extends`로 표현
  - implements를 사용하지 않음에 주의
  - 자손 제약과 구현 인터페이스가 존재한다면 `&` 기호로 연결 (<T extends ExampleClass & ExampleInterface>)

### 1.5 와일드 카드

- 하나의 참조변수로 서로 다른 타입에 대입된 여러 지네릭 객체를 다루기 위해 사용
  - 메서드를 호출할 때마다 다른 타입을 대입해야 할 때 사용
- <T extends Example> vs <? extends Example>
  - **<T extends Example>는 메서드를 호출할 때마다 다른 지네릭 타입을 대입할 수 있게 한 것**
  - **<? extends Example>는 하나의 참조변수로 서로 다른 타입에 대입된 여러 지네릭 객체를 다루기 위한 것**
- <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
- <? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
- <?> : 제한 없음. 모든 타입이 가능. (<? extends Object>와 동일)

```java
  TestList<Parent> testList = new TestList<Parent>(); // 허용
  TestList<Parent> childTestList = new TestList<Child1>(); // 에러

  TestList<? extends Parent> wildCardChildTestList = new TestList<Child1>(); // 허용
  wildCardChildTestList = new TestList<Child2>(); // 허용
  wildCardChildTestList = new TestList<Child3>(); // 허용
```

### 1.6 지네릭 메서드

- 메서드의 선언부에 지네릭 타입이 선언된 메서드 **(클래스의 타입 변수가 선언되는 것이 아님!)**
- 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것
  - 같은 문자 T 일지라도
- 메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같음
  - 메서드 내에서만 사용될 것
- 메서드 호출 시 타입 변수에 타입을 대입해야 하지만 대부분의 경우 컴파일러가 추정 가능하므로 생략
  - 메서드를 호출할 때 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름 생략 불가
- public static <T extends Comparable<? super T>> void sort(List<T> list)
  - 타입 T를 요소로 하는 List를 매개변수로 허용
  - `T`는 Comparable을 구현한 클래스이어야 함
  - Comparable<? super T>이므로 Comparable의 매개변수는 T와 T의 조상 타입이 모두 가능

### 1.7 지네릭 타입의 형변환

- 지네릭 타입과 원시 타입 간의 형변환은 가능
  - 경고가 발생할 뿐
- 대입된 타입과 다른 지네릭 타입 간에는 형변환 불가능
  - Object여도 불가능
- 특정 타입을 `? extends Object`으로의 형변환도 가능
  - 반대로도 가능하지만 확인되지 않은 형변환이라는 경고 발생
- Optional<Object>를 Optional<String>으로 직접 형변환 하는 것은 불가능하지만 와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능
  - Optional<Object> -> Optional<?> -> Optional<T>

### 1.8 지네릭 타입의 제거

- 컴파일러는 지네릭 타입을 이용해서 소스파일을 체크 후 필요한 곳에 형변환을 넣어준 뒤 지네릭 타입 제거
  - \*.class 파일에는 지네릭 타입에 대한 정보가 없음
- 하휘 호환성을 유지하기 위함
  - 원시 타입으로 작성할 수 있도록 한 것도 마찬가지
- 기본적인 제거 과정
  1. 지네릭 타입의 경계를 제거 (~ extends XXX는 XXX로 변경, T만 있을 시 Object로 변경)
  2. 지네릭 타입을 제거한 후 타입이 일치하지 않으면 형변환 추가

## 2. 열거형(enums)

### 2.1 열거형이란?

- 서로 관련된 상수를 편리하게 선언하기 위한 것
- JDK 1.5부터 새로 추가
- 값뿐만 아니라 타입도 관리함 (C언어의 열거형보다 향상된 것)
  - 타입에 안전한 열거형(실제 값뿐만 아니라 타입도 체크)
- 상수와 다르게 열거형 상수는 기존의 소스를 다시 컴파일하지 않아도 됨

### 2.2 열거형의 정의와 사용

- enum 열거형이름 {상수명1, 상수명2, ...}
- statoc 변수를 참조하듯 `열거형이름.상수명`으로 참조
- `==`로 비교가 가능하나 <,> 같은 비교연산자는 사용 불가능
  - compareTo()는 사용 가능
- switch 문의 case 문에도 사용가 능한데 열거형의 이름은 적지 말고 상수만 적어야 함

모든 열거형의 조상 - java.lang.Enum

- getDeclaringClass(), name(), ordinal(), valueOf()를 Enum에서 갖고 있음
  - ordinal()은 0부터 시작하는 열거형의 순서 반환
  - name()은 열거형의 이름을 문자열로 반환
- values(), valueOf(String name)은 컴파일러가 자동적으로 추가해 주는 메서드
  - values()는 열거형의 모든 상수를 배열에 담아 반환
  - valueof()는 상수에 대한 참조를 얻게 해줌

### 2.3 열거형에 멤버 추가하기

- 열거형의 이름 옆에 원하는 값을 괄호와 함께 적어주면 가능
  - 그 후 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가 해야함
    - 열거형 상수를 모두 정의한 다음 다른 멤버들을 추가 해야함
    - 열거형 상수의 마지막에 ';'도 잊지 말 것
- 열거형 생성자는 제어자가 묵시적으로 private
- 여러 값에 맞는 인스턴스 변수와 생성자를 새로 추가한다면 열거형 상수에 여러 값을 저장할 수 있음

열거형에 추상 메서드 추가하기

- 열거형에 추상메서드를 선언하면 각 열거형 상수가 추상 메서드를 반드시 구현해야 함

### 2.4 열거형의 이해

- 열거형 상수 하나하나가 객체
- Enum 클래스의 static 상수인 열거형 상수들의 값은 객체의 주소이며 바뀌지 않으므로 `==`로 비교가 가능한 것
  - 서로의 ordinal을 빼주는 방식으로 구현
