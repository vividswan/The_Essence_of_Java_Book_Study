# Chapter 07 - 객체지향 프로그래밍 2

## 상속

### 상속의 정의와 장점

상속은 기존의 클래스를 재사용하여 새로운 클래스를 생성하는 것

- 코드를 공통적으로 관리할 수 있음
- 재사용성을 높임
- 생성자와 초기화 블럭은 상속되지 않음, 멤버만 상속

종류

- 조상 클래스 : 부모 클래스, 상위 클래스, 기반 클래스
- 자손 클래스 : 자식 클래스, 하위 클래스, 파생된 클래스
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성

### 클래스 간의 관계 - 포함관계

- 하나의 클래스를 미리 작성해 놓고 그것을 다른 클래스의 멤버 변수로 선언하여 포함관계를 맺을 수 있음
- 클래스를 작성하는 것도 쉬워지고 코드도 간결해짐, 코드 관리에 수월
- 다른 클래스에도 재사용 가능

### 클래스 간의 관계 결정하기

- ~은 ~이다. => is a 관계는 `상속관계`
  - ex) 타원은 원이다.
- ~은 ~을 가지고 있다 => has a 관계는 `포함관계`
  - ex) 원은 점을 가지고 있다.

### 단일 상속

- 자바에서는 오직 단일 상속만을 허용
  - 두 개 이상 상속 시 선언부(이름과 매개변수)가 같으면 구별하기 어려움
- 하나는 조상 클래스로, 하나는 클래스 내부에서 인스턴스로 생성 후 사용하는 방식으로 단일 상속의 한계를 해결

### Object클래스 - 모든 클래스의 조상

- Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스
- 상속을 받지 않는 클래스는 컴파일러가 자동으로 `extends Object` 추가
- 모든 조상 클래스의 최상위 클래스로 올라가면 Object

## 오버라이딩(overriding)

### 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

- 새로운 메서드를 제공하는 것보다 사용자가 기대하고 있는 메소드 선언으로 오버라이딩을 하는 것이 바른 선택

### 오버라이딩의 조건

- 이름이 같아야 함
- 매개변수가 같아야 함
- 반환 타입이 같아야 함
  - JDK1.5의 공변 반환타입 추가로 인해 반환타입을 자손 클래스의 타입으로 변경 가능해짐
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가능
- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
  - 조상 클래스 메서드의 예외의 조상인 예외도 선언 불가능
- 인스턴스 메서드를 static메서드로 변경하거나 그 반대의 변경도 불가능
- 조상 클래스의 static 메서드를 자손 클래스에서 똑같은 선언부의 static 메서드로 정의하는 것은 오버라이딩이 아님
  - 클래스 이름으로 접근할 것임으로

### 오버로딩 vs 오버라이딩

오버로딩 : 기존에 없는 새로운 메서드를 정의(new)
오버라이딩 : 상속받은 메서드의 내용을 변경하는 것(change, modify)

### super

- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 데 사용하는 참조 변수
- 조상 클래스의 멤버와 서로 구별해야 할 때 사용하는 것이 좋음
- super 역시 this와 마찬가지로 static 메서드에선 사용 불가능

### super() - 조상 클래스의 생성자

- Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 this() 또는 super()를 호출해야 함
- 그렇지 않다면 컴파일러가 자동으로 `super();`를 생성자의 첫 줄에 삽입
- 생성자에 super()를 선언할 때 조상 클래스의 멤버 변수가 먼저 조상의 생성자로 인해 초기화될 수 있도록 앞 줄에 선언

## package와 import

### 패키지

- 패키지는 클래스(.class)의 묶음
- 클래스의 실제 이름은 패키지명을 포함
- 물리적으로는 하나의 디렉토리
- 하나의 소스파일은 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지에 속해야 함
- 패키지는 `.`을 구분자로 계층구조 구성

### 패키지의 선언

> import 패키지명;

- 소스파일의 첫 번째 문장이어야 함
- 소스파일에 단 한 번 선언
- 클래스와 구분하기 위해 패키지명은 소문자를 사용하는 것이 원칙
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 `이름 없는 패키지`에 속하게 됨
- `-d` 옵션은 지정된 경로를 통해 패키지의 위치를 찾아서 클래스 파일을 생성
- `-cp` 옵션은 일시적으로 클래스 패스 지정 가능

### import문

- 클래스에 일일이 패키지명을 붙여서 사용하기 불편하기 때문에 import문 사용
- import문이 컴파일러에게 소스파일에 사용된 클래스의 패키지 정보를 제공
- ide에서 단축키로도 편하게 접근할 수 있도록 제공

### import문의 선언

- 일반적인 소스파일의 구성

  1. package문
  2. import문
  3. 클래스 선언

- 선언 방법
  - import 패키지명.클래스명;
  - import 패키지명.\*;
  - `클래스명.*`은 하위 클래스를 포함하는 것, 하위 패키지의 클래스까진 포함 x
  - `클래스명.*`은 컴파일러가 해당 패키지에서 일치하는 클래스 이름을 찾아야 하는 수고가 느는 것, 성능상 차이 x

### static import문

static 멤버를 호출할 때 클래스를 생략할 수 있음

- 코드가 간결해짐
- 특정 클래스의 static 멤버를 자주 사용할 때 편리

## 제어자(modifier)

### 제어자란?

- 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
  - 접근제어자 : public, protected, default, private
  - 그 외 : static, final, abstact, native, transient, synchronized, volatile, strictfp
  - 접근 제어자는 한 번에 하나만 선택해서 사용, 나머지는 여러 제어자를 조합해서 사용하는 것이 가능

### static - 클래스의, 공통적인

- 클래스 변수는 인스턴스와 관계없이 같은 값
- static이 붙으면 인스턴스를 생성하지 않고도 사용 가능
- 인스턴스 메서드와 static 메서드의 차이는 메서드 내에서 인스턴스 멤버를 사용하냐의 여부
- 멤버 변수, 메서드, 초기화 블럭에 static이 사용될 수 있음
- static 멤버 변수
  - 모든 인스턴스에 공통적으로 사용되는 클래스 변수
  - 인스턴스를 생성하지 않고도 사용 가능
  - 클래스가 메모리에 로드될 때 생성
- static 메서드
  - 인스턴스를 생성하지 않고도 호출이 가능
  - static 메서드 내에서는 인스턴스 멤버들을 직접 사용 불가능

### final - 마지막의, 변경될 수 없는

- 사용될 수 있는 곳
  - 클래스, 메서드, 멤버 변수, 지역변수
- final 클래스
  - 확장될 수 없는 클래스
  - 다른 클래스의 조상이 될 수 X
- final 메서드
  - 변경할 수 없는 메서드
  - 오버라이딩을 통해 재정의 될 수 없음
- final 멤버 변수, 지역변수
  - 값을 변경할 수 없는 상수
  - final 인스턴스 변수의 경우 생성자에서 초기화할 수 있음

### abstract - 추상의 미완성의

- 메서드의 선언부만 작성하고 실제 구현하지 않은 추상 메서드를 선언하는 데 사용
- 사용될 수 있는 곳
  - 클래스 -> 클래스 내에 추상 메서드가 선언되어 있음을 의미
  - 메서드 -> 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 의미
- 추상 메서드가 없는 경우에도 abstract 클래스인 경우가 있음
  - 상속 후 원하는 메서드만 오버라이딩 하기 위함
- 추상 클래스는 인스턴스를 생성할 수 없다.

### 접근 제어자(access modifier)

- 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한
- 클래스, 멤버 변수, 메서드, 생성자에서 사용 가능
- 종류
  - private : 같은 클래스 내에서만 접근
  - default : 같은 패키지 내에서만 접근
  - protected : 같은 패키지 내 & 다른 패키지의 자손 클래스에서 접근
  - public : 접근 제한 X
  - 접근 범위 : public > protected > (default) > private
- 사용 가능한 접근 제어자
  - 클래스 : public, (default)
  - 메서드, 멤버 변수 : public, protected, (default), private
  - 지역변수 : 없음
- 접근 제어자를 이용한 캡슐화
  - 외부로부터 데이터를 보호하기 위해서
  - 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해서
  - 보통 멤버 변수를 private(상속이 예상될 시 protected)로 선언 후 public getter와 setter를 사용
- 생성자의 접근 제어자
  - private 접근 제어자로 직접 인스턴스를 생성 못하게 한 뒤 public 메서드를 통해 인스턴스에 접근할 수 있도록 제한 가능
  - 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없음 (조상 클래스의 생성자 호출이 불가능하므로)

### 제어자의 조합

- 메서드에 static과 abstact는 함께 사용할 수 없음
- 클래스에 abstract과 final을 동시에 사용할 수 없음
- abstract 메서드의 접근 제어자가 private일 수 없음
  - 자손 클래스에서 구현해 줘야 하기 때문
- 메서드에 private과 final을 같이 사용할 필요는 없음

## 다형성

### 다형성이란?

- 객체지향에서 다형성이란 `여러 가지 형태를 가질 수 있는 능력`을 의미
  - 구체적으론 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 한 것
- 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐
- 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 함
  - 조상 타입의 참조 변수로 자손 타입의 인스턴스를 참조할 수 있음
  - 자손 타입의 참조 변수론 조상 타입의 인스턴스를 참조할 수 없음

### 참조 변수의 형 변환

- 자손 타입에서 조상 타입은 업 캐스팅 : 형 변환 생략 가능
  - 참조 변수가 다를 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 생략 가능
- 조상 타입에서 자손 타입은 다운 캐스팅 : 형변환 생략 불가
- 참조 변수의 형 변환은 참조 변수의 타입을 변경하는 것이므로 실제 인스턴스엔 영향을 미치지 않음
  - 단지 참조 변수의 형 변환을 통해 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위와 개수를 조절하는 것
- 조상 타입의 참조 변수가 조상 타입의 인스턴스를 참조하고 있을 때 자손타입의 참조변수로 형 변환하면 에러 발생

```java
    Car car = new Car();
    FireEngine fe = null;
    // fe = (FireEngine)car; => 오류 발생!
```

조상 타입이 자손 타입의 인스턴스를 참조하고 있을 때는 다운 캐스팅이 가능하다.

```java
    Car car = null;
    FireEngine fe = new FireEngin();
    car = fe;
    FireEngine fe2 = null;
    fe2 = (FireEngine)car;
    // 오류 발생 X
```

- 서로 상속관계에 있는 타입 간의 형변환은 양방향으로 자유롭게 진행될 수 있으나, 참조 변수가 가리키는 인스턴스의 자손 타입으로 형변환은 허용 X
- 참조 변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요

### instanceof연산자

- 참조 변수가 가리키는 인스턴스의 실제 타입을 알아보기 위해 사용
- instanceof의 왼쪽엔 참조 변수, 오른쪽엔 타입(클래스명) 피연산자
- boolean값을 반환함
  - 실제 instanceof 연산 이외에 조상 타입의 instanceof에도 true를 반환
  - 그러므로 true라는 것은 검사한 타입으로 형변환이 가능하다는 의미

### 참조 변수와 인스턴스의 연결

- 멤버 변수의 경우엔 참조 변수의 타입에 따라 달라짐
  - 조상 클래스와 자손 클래스에 중복으로 정의된 경우는 조상 타입의 참조 변수는 조상 클래스 멤버 변수, 자손 타입의 참조 변수는 자손 클래스 멤버 변수
  - 중복 정의되지 않은 경우는 참조 변수에 따른 차이가 없다.
- super와 this로 인스턴스 변수를 구분해서도 사용 가능
  - 멤버 변수들은 주로 private이기 때문에 잘 사용되지는 않음

### 매개변수의 다형성

클래스마다 동일한 로직의 메소드를 만들기보단 공통의 자손 클래스를 extends하게 한 뒤 다형성을 이용해서 하나의 메서드로 구현

- 다른 제품이 추가될 때도 같은 조상 클래스를 상속받게 하면 된다.
- Object 객체를 매개변수로 받는 메소드의 경우엔 모든 타입의 인스턴스를 받을 수 있다.

### 여러 종류의 객체를 배열로 다루기

조상 타입의 참조 변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있음

- 예제로는 Object 타입의 배열을 갖고 있는 Vector 클래스가 있음 (동적으로 크기가 관리되는 객체 배열)

## 추상클래스

### 추상클래스란?

- 추상클래스는 미완성 설계도
- 인스턴스를 생성할 수 없음
- 새로운 클래스를 작성하는 데 있어서 바탕이 되는 조상 클래스의 역할
- 키워드 `abstract`를 붙임

### 추상메서드(abstract method)

- 메서드는 선언부와 구현부(몸통)으로 구현 -> 추상 메서드는 선언부만 작성, 구현부는 작성 X
- abstract 리턴타입 메서드명();
- 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손 클래스 역시 추상 클래스

### 추상클래스의 작성

- 추상화 : 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업
- 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
- abstract를 붙여서 추상메서드로 선언하는 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요
- 공통 조상인 추상 클래스를 이용해서 참조 변수 배열 등의 서로 다른 종류의 인스턴스를 하나의 묶음으로도 다룰 수 있음

## 인터페이스(interface)

### 인터페이스란?

일종의 추상화 클래스

- 추상클래스보다 추상화 정도가 높아서 몸통을 갖춘 일반 메서드나 멤버 변수를 구성원으로 가질 수 없음
- 추상클래스가 미완성 설계도라면 인터페이스는 기본 설계도
- 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성

### 인터페이스의 작성

- 키워드로 class 대신 interface
- 접근 제어자로 public과 default 사용 가능
- 모든 멤버 변수는 public static final이며 이를 생략 가능
- 모든 메서드는 public abstract이며 생략 가능
  - JDK1.8부터 static메서드와 default 메서드는 예외

### 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있음
- 인터페이스는 다중 상속이 가능

### 인터페이스의 구현

- 상속받는 클래스와 크게 다를 건 없지만 `implements`를 사용
- 인터페이스 메서드 일부만 구현하는 클래스는 abstract를 붙여서 추상클래스로 선언
- 상속과 구현을 동시에 할 수 있음
- 인터페이스는 보통 `~할 수 있다.`는 의미의 `able`로 끝나는 이름 사용

### 인터페이스를 이용한 다중 상속

- 인터페이스는 static 상수만 정의할 수 있으므로 충돌이 적고 클래스 이름으로 구분 가능
- 두 개의 클래스로부터 상속을 받아야 하는 상황에선 비중이 높은 쪽을 선택 후 다른 쪽은 클래스 내부에 멤버로 포함 시키는 방식으로 구현
  - 이때 인터페이스를 새로 작성하여 다형적 특성을 이용할 수 있음

### 인터페이스를 이용한 다형성

- 인터페이스도 이를 구현한 클래스의 조상
  - 해당 인터페이스 타입의 참조 변수로 이를 구현한 클래스의 인스턴스 참조 가능
  - 인터페이스 타입으로의 형변환도 가능
  - 인터페이스는 매개변수의 타입으로도 사용될 수 있음
  - 리턴 타입으로 인터페이스의 타입을 지정하는 것 역시 가능(해당 인터페이스를 구현한 클래스의 인스턴스를 반환)

### 인터페이스의 장점

개발 시간을 단축시킬 수 있음

- 호출하는 쪽에서는 선언부만 알면 작업 가능
- 다른 한쪽에선 구현하는 클래스를 작성

표준화가 가능

- 개발자들에게 인터페이스를 구현하여 프로그램의 기본 틀을 작성하도록 함
- 정형화된 프로그램의 개발이 가능

서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음

- 하나의 인터페이스를 공통적으로 구현하게 하면서 관계를 맺어줄 수 있음

독립적인 프로그래밍이 가능

- 선언과 구현을 인터페이스로 분리 가능
- 클래스와 클래스 간의 관계를 직접적인 관계에서 간접적인 관계로 변경

### 인터페이스의 이해

- 염두 해야 할 것
  - 클래스를 사용하는 쪽과 제공하는 쪽이 있음
  - 메서드를 사용하는 쪽은 사용하려는 메서드의 선언부만 알면 됨
- 직접적인 관계인 클래스 두 개를 한 쪽은 인터페이스를 구현하고 한 쪽은 인터페이스를 사용하게 작성
  - 두 클래스는 인터페이스를 매개체로 간접적으로 관계가 변경됨
  - 사용하는 쪽은 구현된 쪽의 영향을 받지 않고 구현된 클래스의 이름을 몰라도, 아직 구현이 안 되어있어도 문제가 되지 않음

### 디폴트 메서드와 static 메서드

- JDK 1.8부터 추상 메서드 외에 디폴트 메서드와 static 메서드가 추가
- static 메서드
  - java.util.Collections가 예시 (static 메서드가 구현되기 전이라 만들어짐)
  - 접근 제어자는 public, 생략 가능
- 디폴트 메서드
  - 추상 메서드가 아님 (인터페이스를 구현한 클래스들에게 영향을 미치지 않음)
  - 접근 제어자는 public, 생략 가능
  - 조상 클래스의 메서드와 충돌 시 디폴트 메서드는 무시되고 조상 클래스의 메서드가 상속
  - 여러 인터페이스 디폴트 메서드 간의 충돌은 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 함

## 내부 클래스(inner class)

### 내부 클래스란?

- 클래스 내에 선언된 클래스
- 장점
  - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근
  - 코드의 복잡성을 줄일 수 있음 (캡슐화)
- 감싸고 있는 클래스는 `외부 클래스`, 안에 있는 클래스는 `내부 클래스`

### 내부 클래스의 종류와 특징

- 변수의 선언 위치에 따른 종류와 같음
- 인스턴스 클래스
  - 외부 클래스의 멤버 변수 선언 위치에 선언
  - 외부 클래스의 인스턴스 멤버처럼 다루어짐
  - 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 주로 사용
- 스태틱 클래스
  - 외부 클래스의 멤버 변수 선언 위치에 선언
  - 외부 클래스의 static 멤버처럼 다루어짐
  - 주로 외부 클래스의 staic 멤버(특히 static 메서드)에서 사용될 목적
- 지역 클래스
  - 외부 클래스의 메서드나 초기화 블럭 안에 선언
  - 선언된 영역 내부에서만 사용 가능
- 익명 클래스
  - 클래스의 선언과 객체의 생성을 동시에 하는 일회용 이름 없는 클래스

### 내부 클래스의 선언

- 내부 클래스의 선언 위치가 변수의 선언 위치와 동일
- 변수와 동일한 유효범위와 접근성을 가짐

### 내부 클래스의 제어자와 접근성

- 내부 클래스가 외부 클래스의 멤버와 같이 간주됨
- 인스턴스 멤버와 static 멤버 간의 규칙이 내부 클래스에도 동일하게 적용
- abstract나 final과 같은 제어자를 사용 가능
- private, protected와 같은 접근 제어자도 사용 가능

### 익명 클래스

- 클래스의 선언과 객체의 생성을 동시에 함
- 단 한 번만 사용될 수 있고 오직 하나의 객체만을 생성하는 일회용 클래스

```java
    new 조상클래스이름() {
        // 멤버 선언
    }

    또는

    new 구현인터페이스이름() {
        // 멤버 선언
    }
```

- 익명 클래스는 이름이 없기 때문에 `외부 클래스명$숫자.class`의 형식으로 클래스 파일명이 결정
