# Chapter 03 - 연산자

연산자는 '연산을 수행하는 기호'

## 연산자와 피연산자

- 연산자 : 연산을 수행하는 기호 `(+, -, *, / 등)`
- 피연산자 : 연산자의 작업 대상 `(변수, 상수, 리터럴, 수식)`
- 연산자는 피연산자로 연산을 수행하고 나면 항상 결괏값을 반환

### 식과 대입 연산자

- 피연산자와 연산자를 조합한 것이 `식`
- 계산하여 결과를 얻는 것을 `식을 평가한다.`라고 함
- 대입 연산자를 사용하면 값을 저장할 수 있는 곳에 결과를 저장할 수 있다.

### 연산자의 종류

- 산술 연산자
  - +, -, \*, /, %, <<, >>
  - 사칙연산과 나머지 연산
- 비교 연산자
  - <, >, >=, <=, ==, !=
  - 크고 작음과 같고 다름을 비교
- 논리 연산자
  - &&, ||, !, &, |, ^, ~
  - AND, OR으로 조건을 연결
- 대입 연산자
  - =
  - 우변의 값을 좌변에 저장
- 기타
  - (type), ?:, instanceof
  - 형변환 연산자, 삼항 연산자, instanceof 연산자
- 피연산자의 개수에 의한 분류도 가능
  - 단항 연산자, 이항 연산자, 삼항 연산자
  - 삼항 연산자는 오직 `? : ` 하나뿐
  - 부호와 증감 연산자는 단항 연산자

### 연산자의 우선순위와 결합 규칙

- 단항 연산자가 이항 연산자보다 우선순위가 높음
- 곱셈과 나눗셈이 뺄셈과 덧셈보다 우선순위가 높음
- 비교연산자보다 산술 연산자가 먼저 수행
- 논리 연산자보다 비교 연산자가 먼저 수행
- 대입 연산자는 연산자 중에서 우선순위가 낮음
- **쉬프트 연산자**는 덧셈 연산자보다 우선순위가 낮음
  - x << 2 + 1은 x << (2+1)
- **비교 연산자 &는 비교 연산자 ==보다 우선순위가 낮음**
  - data & 0xFF == 0 은 data & (0xFF == 0)
- **논리 연산자 중에서는 AND를 의미하는 &, &&가 OR를 의미하는 |, || 보다 우선순위가 낮음**
- 연산자의 결합 규칙
  - 산술 > 비교 > 논리 > 대입 우선순위
  - 단항(1) > 이항(2) > 삼항(3) 우선순위
  - 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽

### 산술 변환

연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 `산술 변환` 또는 `일반 산술 변환`이라 부름

- 두 피연산자의 타입을 같게 일치 시킴
  - 보다 큰 타입으로 일치
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환
- 쉬프트 연산자와 증감 연산자는 예외

## 단항 연산자

### 증감 연산자 ++ --

- 증감 연산자`(++)` : 피연산자의 값을 1 증가시킨다.
- 감소 연산자`(--)` : 피연산자의 값을 1 감소시킨다.
- 타입
  - 전위형 : 값이 참조되기 전에 증가시킨다. (ex: j = ++i;)
  - 후위형 : 값이 참조된 후에 증가시킨다. (ex: j = i++;)
  - 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 둘의 차이가 없음
  - 식에 두 번 이상 포함된 변수에 증감 연산자를 사용하는 것은 피할 것

### 부호 연산자 + -

- 부호 연산자 `-`는 부호를 반대로 변경한 결과를 반환
- 부호 연산자 `+`는 하는 일이 없으므로 쓰이는 일이 거의 없음
- 부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용 가능

## 산술 연산자

### 사칙 연산자 + - \* /

- 곱셈, 나눗셈, 나머지 연산자가 덧셈, 뺄셈 연산자보다 우선순위가 높음
- 피연산자가 정수형인 경우 나누는 수가 0인 경우 에러가 발생
- 나누기 연산자의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입
  - 실제 연산 결과와 다를 수 있음 (반올림 발생 x)
  - 올바른 연산 결과를 얻기 위해서는 두 피연산자 중 한 쪽을 실수형으로 형변환 (한 쪽도 자동 형변환)
- 부동 소수점 값인 0.0f, 0.0d로 나누는 것은 가능하지만 결과는 Infinity(무한대)

```java
byte a = 10;
byte b = 20;
// byte c = a + b; 는 컴파일 에러 -> 연산자 +는 두 개의 피연사들의 자료형을 int로 변환한 다음 덧셈을 수행하기 때문
byte c = (byte) a * b; // 컴파일 에러가 발생하지 않음
// 하지만 c의 값을 출력하면 44
// 300은 byte의 범위를 넘어가기 때문, 충분히 큰 자료형을 사용하는 게 좋다.
```

```java
int a = 1_000_000;
int b = 2_000_000;

long c = a * b;
// a * b 가 이미 int의 범위를 넘어가므로 잘 못된 값이 출력된 이후 형변환되므로 다른 값이 나온다
// (long)a * b <- 이와 같은 형변환으로 해야 올바른 값이 출력된다.
```

```java
int a = 1000000;
int result1 = a * a / a;
int result2 = a / a * a;
// result1 은 이미 a * a에서 오버플로우가 발생하므로 옳지 않은 값
// result2는 올바른 값 출력
// 이처럼 연산의 순서도 중요하다.
```

- 사칙의 피연산자는 문자도 가능
  - 해당 문자의 유니코드로 바뀌어 저장
  - 숫자의 경우 '0'을 빼주는 방법으로 출력 가능

```java
char c1 = 'a';
// char c2 = c1 + 1; int보다 작은 타입의 피연산자는 int로 자동 형변환하므로 컴파일 에러 발생 (char)(c1+1) 이 맞음
char c2 = 'a' + 1; // 상수 또는 리터럴 간의 연산은 컴파일 시에 컴파일러가 계산한 결과로 대체하므로 에러 X
```

- char형과 int형 간의 연산 결과는 int형이므로 char형에 저장하기 위해선 형변환 필요
- 형변환의 성질을 이용해서 소수점 셋째 자리까지만 빼내는 방법 예제 -> (int)(pi \* 1000) / 1000f;
  - 버림이 아닌 반올림은 0.5를 더하거나 Math.round() 사용 `(Math.round(pi * 1000) / 1000.0)`

### 나머지 연산자 %

- 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환
- 오른쪽 피연산자로 0을 사용할 수 없음
- 주로 짝수, 홀수 검사 또는 배수 검사 등에 사용
- 오른쪽 피연산자로 음수도 허용하지만 부호는 무시된 결과 출력

## 비교 연산자

- 두 연산자를 비교하는 데 사용
- 연산 결과는 boolean
- 피연산자의 타입이 서로 다를 시 자료형의 범위가 큰 쪽으로 자동 형변환

### 대소비교 연산자 < > <= >=

값이 크거나 작을 때를 비교, 등호가 붙으면 크거나 같으면, 작거나 같으면을 기준으로 비교

### 등가비교 연산자 == !=

- 두 피연산자의 값이 같은지 다른지를 비교
- `=`는 자바에서는 대입연산자이지 등가비교 연산자가 아님
- 연산을 수행하기 전 형변환을 통해 두 피연산자의 타입을 맞추고 비교
- '10.0==10.0f'는 true, '0.1==0.1f'는 false
  - 정수형과 달리 실수형은 근삿값이 저장되므로 오차가 발생할 수 있음
  - float가 double로 변환된다 해도 빈자리를 0으로 채울 뿐 오차가 적어지는 것이 아님
- 두 문자열을 비교할 때는 `equals()` 메서드 사용
  - 대소문자를 구별하지 않고 싶을 땐 `equalsIgnoreCase()` 사용
  - 문자열을 `==`로 검사 시 객체의 주솟값을 검사하는 것이지 내용을 비교하는 것이 아님

## 논리 연산자

### 논리 연산자 - &&, ||, !

- || (OR결합) => 피연산자 중 어느 한 쪽만 true 이면 true를 결과로 얻음
- && (AND결합) => 피연산자 양쪽 모두 true 이여야 true를 결과로 얻음

### 효율적인 연산

- OR연산의 경우 두 피연산자 중 어느 한 쪽만 참이어도 전체 결과가 참이므로 좌측 피연산자가 참이면 우측 피연산자 값 평가 X
  - 연산 결과가 참일 확률이 높은 피연산자를 왼쪽으로 놓아야 빠른 결과
- AND연산의 경우 두 피연산자 중 어느 한쪽만 거짓이어도 전체 결과가 거짓이므로 좌측 피연산자가 거짓이면 우측 피연산자 값 평가 X
  - 연산 결과가 거짓일 확률이 높은 피연산자를 왼쪽으로 놓아야 빠른 결과

### 논리 부정 연산자 !

- true이면 false를 false이면 true를 반환
- 토글 버튼을 논리적으로 구현 가능
- 적절하게 사용하여 이해되기 쉬운 식을 만들도록 노력할 것
- b가 true 일 때 `!!b`의 결과는 true
  - 단항연산자는 결합 방향이 오른쪽에서 왼쪽이므로 !!b -> !false -> true

### 비트 연산자 & | ^ ~ << >>

- 비트 연산자는 피연산자를 비트 단위로 논리 연산
- 피연산자로 실수를 허용 X
- 종류
  - | (OR연산자) - 피연산자 중 한 쪽의 값이 1이면 결과로 1, 그 외는 0
  - & (AND연산자) - 피연산자 양쪽이 모두 1이어야만 결과로 1, 그 외는 0
  - ^ (XOR연산자) - 피연산자의 값이 서로 다를 때만 결과로 1, 같을 때는 0
- 비트연산에서도 피연산자의 타입을 일치시키는 산술 변환이 일어날 수 있음

### 비트 전환 연산자 ~

- 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꿈
- 논리부정 연산자 `!`와 유사
- 1의 보수 연산자라고도 부름
- p가 있을 때 p에 대한 음의 정수는 `~p+1`
  - 부호연산자 `-`와 동일

### 쉬프트 연산자 << >>

- 피연산자를 2진수로 표현했을 때 오른쪽 또는 왼쪽으로 이동
- 빈자리는 0으로 채워짐
- `>>` 연산자는 부호 있는 정수에서 사용 시 음수를 유지하기 위해 빈자리를 1로 채움, 양수는 0으로 채움
- 쉬프트 연산자의 우측 피연산자는 산술 변환이 필요 없기 때문에 적용 X
- `x << n`은 `x * 2^n`의 결과
- `x >> n`은 `x / 2^n`의 결과
- 쉬프트 연산자가 곱셈, 나눗셈 연산자보다 빠름
  - 그러나 개발 시 가독성을 고려할 것

## 그 외의 연산자

### 조건 연산자 ? :

- 조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자
- 삼항 연산자는 조건 연산자 하나뿐
- 조건식 ? 식1 : 식2
  - 조건식이 true면 식1이, false면 식2
- if문 대신 조건 연산자로 코드를 간단히 할 수 있음
- 가독성이 떨어지므로 필요한 경우에 한 번 정도만 중첩할 것
- 식1, 식2 피연산자의 타입이 다른 경우 산술 변환 발생

### 대입 연산자 = op=

- 변수와 같은 저장 공간에 값 또는 수식의 연산 결과를 저장하는 데 사용
- 저장된 값을 연산 결과로 반환
  - 저장 후 바로 출력도 가능
- 대입 연산자는 연산자들 중 가장 낮은 우선순위
- 연산 진행 방향은 오른쪽에서 왼쪽
- lvalue와 rvalue
  - 대입 연산자의 왼쪽 피연산자를 lvalue
  - 대입 연산자의 오른쪽 피연산자를 rvalue
  - rvalue는 변수, 식, 상수 등이 모두 가능
  - lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 함 (리터럴, 상수 불가능)
- 변수 앞에 `final`을 붙이면 상수
  - 한 번 저장된 값은 바꿀 수 없음
- 복합 대입 연산자
  - 대입 연산자는 다른 연산자(op)와 결합하여 `op=`와 같은 방식으로 사용
  - 주의할 점은 대입연산자의 우변이 둘 이상의 항으로 이루어져 있는 경우 (`i *= 10 +j`는 `i = i * (10 +j)`와 같음)
