# Chapter 03 - 연산자

연산자는 '연산을 수행하는 기호'

## 연산자와 피연산자

- 연산자 : 연산을 수행하는 기호 `(+, -, *, / 등)`
- 피연산자 : 연산자의 작업 대상 `(변수, 상수, 리터럴, 수식)`
- 연산자는 피연산자로 연산을 수행하고 나면 항상 결괏값을 반환

### 식과 대입 연산자

- 피연산자와 연산자를 조합한 것이 `식`
- 계산하여 결과를 얻는 것을 `식을 평가한다.`라고 함
- 대입 연산자를 사용하면 값을 저장할 수 있는 곳에 결과를 저장할 수 있다.

### 연산자의 종류

- 산술 연산자
  - +, -, \*, /, %, <<, >>
  - 사칙연산과 나머지 연산
- 비교 연산자
  - <, >, >=, <=, ==, !=
  - 크고 작음과 같고 다름을 비교
- 논리 연산자
  - %%, ||, !, &, |, ^, ~
  - AND, OR으로 조건을 연결
- 대입 연산자
  - =
  - 우변의 값을 좌변에 저장
- 기타
  - (type), ?:, instanceof
  - 형변환 연산자, 삼항 연산자, instanceof 연산자
- 피연산자의 개수에 의한 분류도 가능
  - 단항 연산자, 이항 연산자, 삼항 연산자
  - 삼항 연산자는 오직 `? : ` 하나뿐
  - 부호와 증감 연산자는 단항 연산자

### 연산자의 우선순위와 결합 규칙

- 단항 연산자가 이항 연산자보다 우선순위가 높음
- 곱셈과 나눗셈이 뺄셈과 덧셈보다 우선순위가 높음
- 비교연산자보다 산술 연산자가 먼저 수행
- 논리 연산자보다 비교 연산자가 먼저 수행
- 대입 연산자는 연산자 중에서 우선순위가 낮음
- **쉬프트 연산자**는 덧셈 연산자보다 우선순위가 낮음
  - x << 2 + 1은 x << (2+1)
- **비교 연산자 &는 비교 연산자 ==보다 우선순위가 낮음**
  - data & 0xFF == 0 은 data & (0xFF == 0)
- **논리 연산자 중에서는 AND를 의미하는 &, &&가 OR를 의미하는 |, || 보다 우선순위가 낮음**
- 연산자의 결합 규칙
  - 산술 > 비교 > 논리 > 대입 우선순위
  - 단항(1) > 이항(2) > 삼항(3) 우선순위
  - 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽

### 산술 변환

연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 `산술 변환` 또는 `일반 산술 변환`이라 부름

- 두 피연산자의 타입을 같게 일치 시킴
  - 보다 큰 타입으로 일치
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환
- 쉬프트 연산자와 증감 연산자는 예외

## 단항 연산자

### 증감 연산자 ++ --

- 증감 연산자`(++)` : 피연산자의 값을 1 증가시킨다.
- 감소 연산자`(--)` : 피연산자의 값을 1 감소시킨다.
- 타입
  - 전위형 : 값이 참조되기 전에 증가시킨다. (ex: j = ++i;)
  - 후위형 : 값이 참조된 후에 증가시킨다. (ex: j = i++;)
  - 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 둘의 차이가 없음
  - 식에 두 번 이상 포함된 변수에 증감 연산자를 사용하는 것은 피할 것

### 부호 연산자 + -

- 부호 연산자 `-`는 부호를 반대로 변경한 결과를 반환
- 부호 연산자 `+`는 하는 일이 없으므로 쓰이는 일이 거의 없음
- 부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용 가능

## 산술 연산자

### 사칙 연산자 + - \* /

- 곱셈, 나눗셈, 나머지 연산자가 덧셈, 뺄셈 연산자보다 우선순위가 높음
- 피연산자가 정수형인 경우 나누는 수가 0인 경우 에러가 발생
- 나누기 연산자의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입
  - 실제 연산 결과와 다를 수 있음 (반올림 발생 x)
  - 올바른 연산 결과를 얻기 위해서는 두 피연산자 중 한 쪽을 실수형으로 형변환 (한 쪽도 자동 형변환)
- 부동 소수점 값인 0.0f, 0.0d로 나누는 것은 가능하지만 결과는 Infinity(무한대)

```java
byte a = 10;
byte b = 20;
// byte c = a + b; 는 컴파일 에러 -> 연산자 +는 두 개의 피연사들의 자료형을 int로 변환한 다음 덧셈을 수행하기 때문
byte c = (byte) a * b; // 컴파일 에러가 발생하지 않음
// 하지만 c의 값을 출력하면 44
// 300은 byte의 범위를 넘어가기 때문, 충분히 큰 자료형을 사용하는 게 좋다.
```

```java
int a = 1_000_000;
int b = 2_000_000;

long c = a * b;
// a * b 가 이미 int의 범위를 넘어가므로 잘 못된 값이 출력된 이후 형변환되므로 다른 값이 나온다
// (long)a * b <- 이와 같은 형변환으로 해야 올바른 값이 출력된다.
```

```java
int a = 1000000;
int result1 = a * a / a;
int result2 = a / a * a;
// result1 은 이미 a * a에서 오버플로우가 발생하므로 옳지 않은 값
// result2는 올바른 값 출력
// 이처럼 연산의 순서도 중요하다.
```

- 사칙의 피연산자는 문자도 가능
  - 해당 문자의 유니코드로 바뀌어 저장
  - 숫자의 경우 '0'을 빼주는 방법으로 출력 가능

```java
char c1 = 'a';
// char c2 = c1 + 1; int보다 작은 타입의 피연산자는 int로 자동 형변환하므로 컴파일 에러 발생 (char)(c1+1) 이 맞음
char c2 = 'a' + 1; // 상수 또는 리터럴 간의 연산은 컴파일 시에 컴파일러가 계산한 결과로 대체하므로 에러 X
```

- char형과 int형 간의 연산 결과는 int형이므로 char형에 저장하기 위해선 형변환 필요
- 형변환의 성질을 이용해서 소수점 셋째 자리까지만 빼내는 방법 예제 -> (int)(pi \* 1000) / 1000f;
  - 버림이 아닌 반올림은 0.5를 더하거나 Math.round() 사용 `(Math.round(pi * 1000) / 1000.0)`

### 나머지 연산자 %

- 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환
- 오른쪽 피연산자로 0을 사용할 수 없음
- 주로 짝수, 홀수 검사 또는 배수 검사 등에 사용
- 오른쪽 피연산자로 음수도 허용하지만 부호는 무시된 결과 출력
