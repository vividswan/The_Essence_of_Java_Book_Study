# Chapter 06 - 객체지향 프로그래밍 1

## 객체지향언어

### 객체지향언어의 역사

- 객체지향 이론의 기본 개념은 실제 세계는 객체로 이루어져 있고, 모든 사건들은 객체 간의 상호작용
- 최초의 객체지향 언어는 시뮬라 (1960년도 중반)
- 자바의 1995년도 발표 뒤 1990년대 말 인터넷 발전과 함께 객체지향언어도 프로그래밍언어의 주류가 됨

### 객체지향언어
- 코드의 재사용성이 높음
    - 새로운 코드를 작성할 때 기존의 코드를 이용
- 코드 간의 관리 용이
    - 코드 간의 관계를 이용해서 적은 노력으로 코드를 변경
- 신뢰성이 높은 프로그래밍
    - 제어자와 메서드를 활용한 데이터 보호 및 올바른 값 유지
    - 코드의 중복 제거 (불일치로 인한 오동작 방지)

## 클래스와 객체

### 클래스와 객체의 정의와 용도

클래스
- 클래스의 정의
    - 객체를 정의해 놓은 것
- 클래스의 용도
    - 클래스는 객체를 생성하는 데 사용

객체
- 객체의 정의
    - 실제로 존재하는 사물이나 개념
- 객체의 용도
    - 객체가 가지고 있는 기능과 속성에 따라 다름
- 유형의 객체
    - 책상, 의자, 자동차 등등...
- 무형의 객체
    - 수학공식, 프로그램 에러와 같은 논리 & 개념

클래스와 객체의 관계는 제품 설계도와 제품과 같은 관계
- 하나의 설계도만 만들어 놓으면 제품을 만드는 일이 쉬워짐
- JDK에서는 프로그래밍을 위해 많은 수의 클래스를 기본적으로 제공

### 객체와 인스턴스

- 인스턴스화 : 클래스로부터 객체를 만드는 과정
- 인스턴스 : 어떤 클래스로부터 만들어진 객체

좀 더 나은 표현 -> `책상은 객체다.`,  `책상은 책상 클래스의 인스턴스다.`

클래스 -> (인스턴스화) -> 인스턴스(객체)

### 객체의 구성요소 - 속성과 기능

객체는 다수의 속성과 다수의 기능을 가짐 -> 객체는 속성과 기능의 집합

객체가 가진 속성과 기능을 멤버라 함

- 속성
    - 멤버 변수, 특성, 필드, 상태
- 기능
    - 메서드, 함수, 행위

선언 시 멤버 변수들을 모아서 먼저 선언 후 메서드끼리 모아서 선언

### 인스턴스의 생성과 사용

- 클래스명 변수명;
    - ex) Tv t;
    - Tv 클래스 타입의 참조 변수 t를 선언
    - 메모리에 참조 변수 t를 위한 공간 생성
- 변수명 = new 클래스명();
    - ex) t = new Tv();
    - 연산자 new에 의해 Tv 클래스의 인스턴스가 메모리의 빈 공간에 생성
    - 멤버 변수는 각 자료형에 해당하는 기본값으로 초기화
    - 대입 연산자에 의해 생성된 객체의 주솟값이 참조 변수 t에 저장
- (참조 변수).(멤버 변수) = 리터럴;
    - ex) t.channel = 7;
    - 멤버 변수에게 리터럴 값을 저장
    - `(참조 변수).(멤버 변수)`로 속성 사용 가능
- (참조 변수).메서드();
    - ex) t.channelDown();
    - 인스턴스의 메서드 호출

인스턴스는 참조 변수를 통해서만 다룰 수 있음  
참조 변수의 타입은 인스턴스 타입과 일치해야 함

### 객체 배열
객체 역시 배열로 다루는 것이 가능
- 배열 안에 객체의 주소가 저장
    - 그러므로 객체 배열은 참조 변수들을 하나로 묶은 `참조 변수 배열`
- `생성 직후는 기본 값인 null로 자동 초기화`
    - 주의할 것
- 객체 배열도 같은 타입의 객체만 저장 가능
    - 다형성으로 여러 종류의 객체를 다룰 수 있다.

### 클래스의 또 다른 정의

클래스란 데이터와 함수의 결합
- 프로그래밍에서 데이터 저장 형태의 발전 과정
    1. 변수 -> 하나의 데이터만 저장
    2. 배열 -> 같은 종류의 데이터를 하나의 집합으로 저장
    3. 구조체 -> 서로 관련된 여러 데이터를 하나의 집합으로 저장 (종류에 관계 x)
    4. 클래스 -> 데이터와 함수의 결합(구조체 + 함수)

클래스 - 사용자 정의 타입(user-defined type)
- primitive type 자료형 외에 프로그래머가 관련된 변수들을 묶어서 타입을 새로 추가
- 기본형의 종류는 8개
- 연관 있는 데이터를 묶어서 클래스로 정의하는 것이 객체지향적 설계
- 제어자와 메서드를 이용해서 자료에 대한 조건들을 코드에 쉽게 반영 가능

## 변수와 메서드

### 선언 위치에 따른 변수의 종류

멤버 변수(클래스 영역에 선언)
- 클래스 변수
    - 클래스가 메모리에 올라갈 때 생성
    - static을 붙여야 함
    - 인스턴스가 없이도 바로 사용 가능
    - `(클래스 이름).(클래스 변수)`와 같은 형식으로 사용할 것
- 인스턴스 변수
    - 인스턴스가 생성되었을 때 생성
    - 먼저 인스턴스를 생성해야 함
    - 각 인스턴스마다 고유한 값

지역변수
- 변수 선언문이 수행되었을 때 생성
- 클래스 영역 이외의 메서드, 생성자, 초기화 블록 내부에서 선언
- 메서드가 종료되면 소멸

### 클래스 변수와 인스턴스 변수
- 카드로 예제) 무늬 숫자는 인스턴스 변수, 폭, 높이는 클래스 변수
- 인스턴스 변수는 인스턴스가 생성될 때마다 생성
    - 각기 다른 값을 유지
- 클래스 변수는 모든 인스턴스가 하나의 저장 공간을 공유
    - 항상 공통된 값

### 메서드
- 특정 작업을 수행하는 일련의 문장들을 묶은 것
- 입력과 출력만 알면 됨 -> 블랙박스라고도 함
- 메서드의 이점
    - 높은 재사용성 (한 번 만든 메서드는 몇 번이고 호출 및 다른 프로그램에서 사용 가능)
    - 중복된 코드의 제거(반복적으로 나타나는 문장들은 메서드로 만들어서 사용할 것)
    - 프로그램의 구조화 (메서드를 작업단위로 만들어 놓고 완성해가는 것도 좋은 방법)

### 메서드의 선언과 구현
- 메서드는 선언부(머리)와 구현부(몸통)로 이루어짐
- 메서드 선언부
    - 반환 타입 + 메서드 이름 + 매개변수 선언으로 이루어짐
    - 변경사항이 발생하지 않도록 신중히 (사용하는 모든 코드를 바꿔야 하므로)
- 매개변수 선언
    - 필요한 값의 개수만큼 쉼표로 구분하여 선언
    - 두 변수의 타입이 같아도 변수 타입 생략 불가
- 메서드의 이름
    - 동사인 경우가 많음
    - 이름으로도 기능을 알 수 있게 함축 & 의미 있는 이름이 좋다.
- 반환 타입
    - 출력 결과인 반환값의 타입
    - 반환값이 없을 시 `void`
- 메서드의 구현부
    - 선언부 다음에 오는 괄호 -> {}
    - 메서드 호출 시 수행될 문장들
- return 문
    - void가 아닐 경우 반드시 `return 반환값;`
    - 반환 값의 타입은 반환 타입과 일치 or 자동 형변환이 가능한 것으로
    - 매개변수는 여러 개가 가능하지만 return문은 단 하나의 값만 반환
- 지역변수
    - 메서드 내에 선언된 변수들
    - 그 메서드 내에서만 사용 가능

### 메서드의 호출
- 메서드 이름(값1, 값2, ...);
- 인자와 매개변수
    - 메서드 호출 시 괄호 안에 지정해 준 값들이 인자 혹은 인수
    - 인자의 개수와 순서는 메서드의 매개변수와 일치해야 함
- 메서드 실행 흐름
    - 같은 클래스 내의 메서드끼리는 참조 변수를 사용하지 않고도 서로 호출이 가능
    - `하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드 호출 불가능`

### return 문
- return 문은 현재 실행 중인 메서드를 종료하고 호출한 메서드로 돌아감
- 반환값의 유무에 관계없이 적어도 하나의 return 문이 있어야 함
    - void에서 생략 시 컴파일러가 마지막에 `return;` 처리
- return 문 위치에 수식도 가능
    - 수식이 반환되는 것이 아닌 수식을 계산한 결과가 반환
- 매개변수의 유효성 검사
    - 매개변수의 유효성 검사는 구현부를 작성할 때 가장 중요한 일
    - 나누기의 결과를 return 하는 메서드에서 0으로 나누는 등의 예외는 `return 0;`으로 처리

### JVM의 메모리 구조

JVM은 응용 프로그램이 실행되면 시스템으로부터 프로그램을 수행하는 데 필요한 메모리를 할당받고 용도에 따라 여러 영역으로 나누어서 관리
- 메서드 영역 (method area)
    - 사용되는 클래스의 클래스 파일(*.class)를 읽은 후 클래스에 대한 정보(클래스 데이터)를 저장
    - 클래스 변수도 함께 저장
- 힙(heap)
    - 인스턴스가 생성되는 공간
    - 프로그램 실행 중 생성되는 인스턴스는 모두 힙 영역에 저장
- 호출 스택(call stack 또는 execution stack)
    - 메서드의 작업에 필요한 메모리 공간 제공
    - 메서드 호출 시 호출된 메서드를 위한 메모리를 할당 (스택에 할당받음)
    - 할당된 메모리는 지역변수(매개변수 포함) 들과 연산의 중간 결과 등을 저장하는 데 사용
    - 각 메서드를 위한 메모리상의 작업 공간은 서로 구별됨
    - 메서드 수행 중 다른 메서드를 호출하면 그 메서드의 바로 위에 호출된 메서드를 위한 공간 마련 (그러므로 호출 스택의 가장 위에 있는 메서드가 현재 실행 중인 메서드)
    - 처음엔 main()이 올라감
    - 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환 후 비워짐

### 기본형 매개변수와 참조형 매개변수
- 기본형 매개변수는 변수의 값을 읽기만 할 수 있다. (read only)
    - 매개변수의 타입이 기본형일 때는 기본형 값이 복사되기 때문
    - 호출된 메서드의 매개변수는 복사된 값이므로 수정해도 원본엔 아무런 영향을 미치지 못함
- 참조형 매개변수는 변수의 값을 읽고 변경할 수 있다. (read & write)
    - 매개변수의 타입이 참조형일 때는 인스턴스의 주소가 복사되기 때문
    - `값이 저장된 주소`를 넘겨주었으므로 변경도 가능 (같은 객체를 가리키므로)
- 배열도 객체와 같이 참조 변수를 통해 데이터가 저장된 공간에 접근하므로 매개변수로 값을 수정할 수 있다.

### 참조형 반환 타입
- 매개변수뿐만 아니라 반환 타입도 참조형이 될 수 있음
- `객체의 주소`인 정숫값이 반환되는 것
- 호출 결과를 같은 타입의 참조 변수이어야 함

### 재귀 호출
- 메서드 내부에서 메서드 자신을 다시 호출하는 것
- 메서드를 종료하는 조건이 반드시 필요
    - 계속해서 재귀 호출만 일어나게 된다면 스택오버플로우 에러 발생
    - 매개변수의 유효성 검사를 잘 할 것
- 대부분의 재귀 호출은 반복문으로 작성 가능
    - 재귀 호출은 반복문보다 매개변수 복사와 종료, 복귀할 주소 저장 등이 추가적으로 필요하기 때문에 수행 시간이 더 오래 걸림
    - 그럼에도 재귀 호출이 주는 논리적 간결함 때문에 사용
    
### 클래스 메서드(static)와 인스턴스 메서드
- static이 붙어있는 메서드는 클래스 메서드, 그렇지 않은 메서드는 인스턴스 메서드
- 클래스 메서드도 클래스 변수처럼 `(클래스 이름).(메서드 이름(매개변수))`와 같은 식으로 호출 가능
- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드
- 클래스 메서드는 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드
- 유의 사항
    - 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙일 것
    - 클래스 변수는 인스턴스를 생성하지 않아도 사용 가능
    - 클래스 메서드는 인스턴스 변수를 사용할 수 없음(클래스 메서드 사용 시 인스턴스 변수가 존재하지 않을 수 있으므로)
    - 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려

### 클래스 멤버와 인스턴스 멤버 간의 참조와 호출
- 클래스 멤버 : 클래스 변수 & 클래스 메서드
- 인스턴스 멤버 : 인스턴스 변수 & 인스턴스 메서드
- 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 함
    - 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문
    - ex) int iv와 같은 인스턴스 변수를 바로 println(iv) 할 순 없고 특정 인스턴스 c를 만든 후 `println(c.iv)`
- 인스턴스 멤버는 같은 인스턴스 멤버나 클래스 멤버 모두 참조 또는 호출 가능
    - 하나의 인스턴스 멤버가 존재한다는 것은 이미 인스턴스가 생성되었음을 의미, 클래스 멤버는 그 시점에 이미 항상 존재

## 오버로딩

### 오버로딩이란?
- 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
    - 오버로딩은 많이 싣는다는 뜻 -> 하나의 메서드로 여러 기능을 구별하는 기능

### 오버로딩의 조건
- 메서드 이름이 같아야 함
- 매개변수의 개수 또는 타입이 달라야 함
- 반환 타입은 오버로딩을 구현하는데 아무런 영향을 못 준다.

### 오버로딩의 예
- `println` 메서드
- 정의된 메서드가 달라도 같은 로직을 수행

### 오버로딩의 장점
- 타입과 상황에 따라 메서드 각각의 이름을 짓고 사용하기 위해 기억하는 과정이 줄어든다.

### 가변 인자와 오버로딩
- 가변 인자 : 매개변수 제일 마지막에 `타입... 변수명`으로 선언
- 가변 인자는 내부적으로 배열을 사용
- 매개변수의 타입이 배열일 시 반드시 인자가 필요함으로 null이나 0인 배열을 인자로 지정해 줘야 하지만 가변 인자는 그런 불편함이 없음
- 가변 인자를 선언한 메서드 오버로딩 시 인자만으로 구별되지 못하는 경우가 쉽게 발생하므로 가변 인자를 사용한 메서드는 사용하지 않는 게 좋음

## 생성자

### 생성자란?
- 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드`
- 메서드와 유사한 구조이나 리턴 값이 없다. (void를 명시 X)
- 생성자의 이름은 클래스와 같아야 한다.
- 생성자도 오버로딩이 가능
    - 하나의 클래스의 여러 생성자 존재 가능
- 연산자 new가 인스턴스를 생성하는 것, 생성자가 인스턴스를 생성하는 것이 아님
- 생성 과정
    - 연산자 new에 의해서 메모리(heap)에 클래스의 인스턴스 생성
    - 생성자가 호출되어 수행
    - 연산자 new의 결과로 생성된 인스턴스의 주소가 반환

### 기본 생성자
- 클래스는 반드시 하나 이상의 생성자가 정의되어야 함
- 클래스에 생성자가 하나도 정의되지 않을 경우 컴파일러가 기본 생성자를 추가 후 컴파일
    - 하나라도 생성자가 있다면 자동으로 추가 X
- 클래스이름() {}

### 매개변수가 있는 생성자
- 매개변수를 선언하여 호출 시 값을 넘겨받을 수 있음 (인스턴스 초기화 작업)
- 매개변수를 갖는 생성자를 사용하는 것이 코드를 간결&직관적으로 만들 수 있음

### 생성자에서 다른 생성자 호출하기 - this(), this
- 생성자 간에 호출 가능한 조건
    - 생성자의 이름으로 클래스 이름 대신 this를 사용
    - **한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능**
- 생성자 초기화 작업 도중 다른 생성자 호출 시 호출된 다른 생성자 내에서도 멤버 변수들의 값을 초기화할 것이므로 다른 생성자를 호출하기 이전의 작업이 무의미해짐
    - 그러므로 첫 줄에서만 다른 생성자를 호출
    - this(), this(매개변수) ...
- 매개변수로 선언된 변수의 이름과 인스턴스 변수 이름이 같을 경우엔 인스턴스 변수 앞에 this를 사용
    - this는 참조 변수로 인스턴스 자신을 가리킴
    - this를 사용할 수 있는 것은 인스턴스 멤버뿐 (static 메서드는 인스턴스를 생성하지 않고도 호출 가능함으로)
    - 생성자를 포함한 모든 인스턴스 메서드에는 자신이 관련된 인스턴스를 가리키는 참조 변수 'this'가 지역변수로 숨겨진 채로 존재

### 생성자를 이용한 인스턴스의 복사
- 생성자의 매개변수로 참조 변수를 넘기고 참조 변수가 가리키는 인스턴스의 인스턴스 변수들의 값을 자신으로 복사
- 서로 독립적으로 메모리 공간에 존재하는 별도의 인스턴스이므로 서로의 값 변경은 영향이 없음

## 변수의 초기화

### 변수의 초기화
- 멤버 변수는 촉화 하지 않아도 자동으로 변수의 자료형에 맞는 기본값으로 초기화
    - 멤버 변수 = 클래스 변수 or 인스턴스 변수
- **지역변수는 사용하기 전에 반드시 초기화할 것**
- 멤버 변수의 초기화 방법
    - 명시적 초기화
    - 생성자
    - 초기화 블럭 (인스턴스 초기화 블럭, 클래스 초기화 블럭)

### 명시적 초기화
- 변수를 선언과 동시에 초기화하는 것
- 가장 기본적이면서도 간단

### 초기화 블럭
- 클래스 초기화 블럭
    - 클래스 변수의 복잡한 초기화에 사용
    - 인스턴스 초기화 블럭 앞에 static을 덧붙이면 됨
    - 클래스가 메모리에 처음 로딩될 때 한 번만 수행
- 인스턴스 초기화 블럭
    - 인스턴스 변수의 복잡한 초기화에 사용
    - 클래스 내에 블럭을 만들고 코드 작성
    - 생성자와 같이 인스턴스를 생성할 때
    - 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용

### 멤버 변수의 초기화 시기와 순서
- 클래스 변수
    - 초기화 시점 : 클래스가 처음 로딩될 때 단 한 번 초기화
    - 초기화 순서 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수
    - 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화
    - 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 -> 생성자
- 여기서 기본값은 각 자료형에 맞는 기본값
- 인스턴스 변수는 생성자로 인한 할당이 명시적 초기화로 인한 할당 뒤 순서
